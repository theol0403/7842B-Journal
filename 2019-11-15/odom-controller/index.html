<!DOCTYPE html> <html lang="en-US"> <head> <meta charset="UTF-8" /> <meta http-equiv="X-UA-Compatible" content="IE=Edge" /> <meta name="theme-color" content="#94ddff" /> <meta http-equiv="cache-control" content="no-cache" /> <meta http-equiv="expires" content="0" /> <meta http-equiv="pragma" content="no-cache" /> <title>Odom Controller - 7842B Journal</title> <link rel="shortcut icon" href="https://theol0403.github.io/7842B-Journal/assets/images/favicon.ico" type="image/x-icon" /> <link rel="stylesheet" href="https://theol0403.github.io/7842B-Journal/assets/css/just-the-docs.css" /> <script type="text/javascript" src="https://theol0403.github.io/7842B-Journal/assets/js/vendor/lunr.min.js" ></script> <script type="text/javascript" src="https://theol0403.github.io/7842B-Journal/assets/js/just-the-docs.js" ></script> <meta name="viewport" content="width=device-width, initial-scale=1" /> <!-- Begin Jekyll SEO tag v2.7.1 --> <title>Odom Controller | 7842B Journal</title> <meta name="generator" content="Jekyll v4.2.0" /> <meta property="og:title" content="Odom Controller" /> <meta property="og:locale" content="en_US" /> <meta name="description" content="Table of contents" /> <meta property="og:description" content="Table of contents" /> <link rel="canonical" href="https://theol0403.github.io/7842B-Journal/2019-11-15/odom-controller/" /> <meta property="og:url" content="https://theol0403.github.io/7842B-Journal/2019-11-15/odom-controller/" /> <meta property="og:site_name" content="7842B Journal" /> <meta property="og:type" content="article" /> <meta property="article:published_time" content="2019-11-15T00:00:00+00:00" /> <meta name="twitter:card" content="summary" /> <meta property="twitter:title" content="Odom Controller" /> <script type="application/ld+json"> {"@type":"BlogPosting","description":"Table of contents","mainEntityOfPage":{"@type":"WebPage","@id":"https://theol0403.github.io/7842B-Journal/2019-11-15/odom-controller/"},"url":"https://theol0403.github.io/7842B-Journal/2019-11-15/odom-controller/","headline":"Odom Controller","dateModified":"2019-11-15T00:00:00+00:00","datePublished":"2019-11-15T00:00:00+00:00","@context":"https://schema.org"}</script> <!-- End Jekyll SEO tag --> </head> <body> <svg xmlns="http://www.w3.org/2000/svg" style="display: none;"> <symbol id="link" viewBox="0 0 16 16"> <title>Link</title> <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path> </symbol> </svg> <div class="page-wrap"> <div class="side-bar"> <div class="site-header"> <a href="https://theol0403.github.io/7842B-Journal" class="site-title lh-tight"><span class="bteam">7842B</span>&nbsp;Journal </a> <button class="menu-button fs-3 js-main-nav-trigger" data-text-toggle="Hide" type="button">Menu</button> </div> <div class="navigation main-nav js-main-nav"> <nav role="navigation" aria-label="Main navigation"> <ul class="navigation-list"><li class="navigation-list-item active"><a href="https://theol0403.github.io/7842B-Journal/404.html" class="navigation-list-link"></a></li><li class="navigation-list-item"><a href="https://theol0403.github.io/7842B-Journal/" class="navigation-list-link">Home</a><ul class="navigation-list-child-list "></ul></li><li class="navigation-list-item"><a href="https://theol0403.github.io/7842B-Journal/programming" class="navigation-list-link">Programming</a><ul class="navigation-list-child-list "><li class="navigation-list-item "><a href="https://theol0403.github.io/7842B-Journal/programming/skills" class="navigation-list-link">Skills</a><ul class="navigation-list-child-list"><li class="navigation-list-item "> <a href="https://theol0403.github.io/7842B-Journal/2021-02-04/v1-skills/" class="navigation-list-link">V1 Skills</a> </li><li class="navigation-list-item "> <a href="https://theol0403.github.io/7842B-Journal/2021-03-01/v2-skills/" class="navigation-list-link">V2 Skills</a> </li><li class="navigation-list-item "> <a href="https://theol0403.github.io/7842B-Journal/2021-04-03/v3-skills/" class="navigation-list-link">V3 Skills</a> </li></ul></li><li class="navigation-list-item "><a href="https://theol0403.github.io/7842B-Journal/programming/intake" class="navigation-list-link">Intake Automation</a><ul class="navigation-list-child-list"><li class="navigation-list-item "> <a href="https://theol0403.github.io/7842B-Journal/2021-03-24/intake-log-2/" class="navigation-list-link">Intake Log 2</a> </li><li class="navigation-list-item "> <a href="https://theol0403.github.io/7842B-Journal/2021-02-20/intake-log-1/" class="navigation-list-link">Intake Log 1</a> </li></ul></li><li class="navigation-list-item "><a href="https://theol0403.github.io/7842B-Journal/programming/motion" class="navigation-list-link">Motion Control</a><ul class="navigation-list-child-list"><li class="navigation-list-item "> <a href="https://theol0403.github.io/7842B-Journal/2020-06-01/introduction/" class="navigation-list-link">Introduction to Trajectories</a> </li><li class="navigation-list-item "> <a href="https://theol0403.github.io/7842B-Journal/2020-06-22/trajectory-journal/" class="navigation-list-link">Trajectory Journal</a> </li></ul></li></ul></li><li class="navigation-list-item"><a href="https://theol0403.github.io/7842B-Journal/build" class="navigation-list-link">Build</a><ul class="navigation-list-child-list "><li class="navigation-list-item "><a href="https://theol0403.github.io/7842B-Journal/build/v1/" class="navigation-list-link">Robot V1</a><ul class="navigation-list-child-list"><li class="navigation-list-item "> <a href="https://theol0403.github.io/7842B-Journal/2021-01-20/intakes/" class="navigation-list-link">Intake Design</a> </li><li class="navigation-list-item "> <a href="https://theol0403.github.io/7842B-Journal/2021-01-15/chassis/" class="navigation-list-link">Robot Chassis</a> </li></ul></li><li class="navigation-list-item "><a href="https://theol0403.github.io/7842B-Journal/build/v2/" class="navigation-list-link">Robot V2</a><ul class="navigation-list-child-list"><li class="navigation-list-item "> <a href="https://theol0403.github.io/7842B-Journal/2021-02-28/upgrades/" class="navigation-list-link">Upgrades</a> </li><li class="navigation-list-item "> <a href="https://theol0403.github.io/7842B-Journal/2021-02-26/hood-changes/" class="navigation-list-link">Hood Challenges</a> </li><li class="navigation-list-item "> <a href="https://theol0403.github.io/7842B-Journal/2021-02-23/deflector/" class="navigation-list-link">Deflector</a> </li></ul></li><li class="navigation-list-item "><a href="https://theol0403.github.io/7842B-Journal/build/v3/" class="navigation-list-link">Robot V3</a><ul class="navigation-list-child-list"><li class="navigation-list-item "> <a href="https://theol0403.github.io/7842B-Journal/2021-04-02/hood-catapult/" class="navigation-list-link">Hood Catapult</a> </li><li class="navigation-list-item "> <a href="https://theol0403.github.io/7842B-Journal/2021-03-29/intake-changes/" class="navigation-list-link">Intake changes</a> </li><li class="navigation-list-item "> <a href="https://theol0403.github.io/7842B-Journal/2021-03-26/roller-changes/" class="navigation-list-link">Roller changes</a> </li></ul></li></ul></li><li class="navigation-list-item active"><a href="https://theol0403.github.io/7842B-Journal/archive" class="navigation-list-link">Archive</a><ul class="navigation-list-child-list "><li class="navigation-list-item "><a href="https://theol0403.github.io/7842B-Journal/2019-11-28/lib7842/" class="navigation-list-link">lib7842</a></li><li class="navigation-list-item "><a href="https://theol0403.github.io/7842B-Journal/2019-11-25/pure-pursuit/" class="navigation-list-link">Pure Pursuit</a></li><li class="navigation-list-item "><a href="https://theol0403.github.io/7842B-Journal/2019-11-20/odom-x-controller/" class="navigation-list-link">Odom X Controller</a></li><li class="navigation-list-item active"><a href="https://theol0403.github.io/7842B-Journal/2019-11-15/odom-controller/" class="navigation-list-link active">Odom Controller</a></li><li class="navigation-list-item "><a href="https://theol0403.github.io/7842B-Journal/2019-11-10/tests/" class="navigation-list-link">Unit Tests</a></li><li class="navigation-list-item "><a href="https://theol0403.github.io/7842B-Journal/2019-10-19/gui/" class="navigation-list-link">GUI</a></li><li class="navigation-list-item "><a href="https://theol0403.github.io/7842B-Journal/2019-10-18/task-wrapper/" class="navigation-list-link">Task Wrapper</a></li><li class="navigation-list-item "><a href="https://theol0403.github.io/7842B-Journal/2019-10-16/statemachine/" class="navigation-list-link">State Machine</a></li><li class="navigation-list-item "><a href="https://theol0403.github.io/7842B-Journal/2019-10-15/motion-algorithms/" class="navigation-list-link">Motion Algorithms</a></li><li class="navigation-list-item "><a href="https://theol0403.github.io/7842B-Journal/2019-08-19/robot-showcase/" class="navigation-list-link">2018-19 Showcase</a></li></ul></li></ul> </nav> </div> </div> <div class="main-content-wrap js-main-content" tabindex="0"> <div class="main-content"> <div class="page-header js-page-header"> <div class="search"> <div class="search-input-wrap"> <input type="text" class="js-search-input search-input" tabindex="0" placeholder="Search 7842B Journal" aria-label="Search 7842B Journal" autocomplete="off"> <svg width="14" height="14" viewBox="0 0 28 28" xmlns="http://www.w3.org/2000/svg" class="search-icon"><title>Search</title><g fill-rule="nonzero"><path d="M17.332 20.735c-5.537 0-10-4.6-10-10.247 0-5.646 4.463-10.247 10-10.247 5.536 0 10 4.601 10 10.247s-4.464 10.247-10 10.247zm0-4c3.3 0 6-2.783 6-6.247 0-3.463-2.7-6.247-6-6.247s-6 2.784-6 6.247c0 3.464 2.7 6.247 6 6.247z"/><path d="M11.672 13.791L.192 25.271 3.02 28.1 14.5 16.62z"/></g></svg> </div> <div class="js-search-results search-results-wrap"></div> </div> <ul class="list-style-none text-small aux-nav"> <li class="d-inline-block my-0 mr-2"><a href="https://theol0403.github.io/7842B-Journal/build">Build</a></li> <li class="d-inline-block my-0"><a href="https://theol0403.github.io/7842B-Journal/programming">Programming</a></li> </ul> </div> <div class="page"> <nav class="breadcrumb-nav"> <ol class="breadcrumb-nav-list"> <li class="breadcrumb-nav-list-item"><a href="https://theol0403.github.io/7842B-Journal/archive">Archive</a></li> <li class="breadcrumb-nav-list-item"><span>Odom Controller</span></li> </ol> </nav> <div id="main-content" class="page-content" role="main"> <h1> <a href="https://theol0403.github.io/7842B-Journal/2019-11-15/odom-controller/"> Odom Controller </a> - November 15, 2019 </h1> <article><!-- prettier-ignore-start --> <h2 class="no_toc text-delta" id="table-of-contents"> <a href="#table-of-contents" class="anchor-heading"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#link"></use></svg></a> Table of contents </h2> <ol id="markdown-toc"> <li><a href="#basic-movement" id="markdown-toc-basic-movement">Basic Movement</a> <ol> <li><a href="#pid-to-heading-and-distance" id="markdown-toc-pid-to-heading-and-distance">PID to Heading and Distance</a></li> </ol> </li> <li><a href="#adaptive-pid-seeking" id="markdown-toc-adaptive-pid-seeking">Adaptive PID Seeking</a></li> <li><a href="#settling" id="markdown-toc-settling">Settling</a></li> <li><a href="#turning" id="markdown-toc-turning">Turning</a></li> <li><a href="#odomcontroller-code" id="markdown-toc-odomcontroller-code">OdomController Code</a></li> </ol> <!-- prettier-ignore-end --> <p>In order to move to specific coordinates, I needed to design a versatile controller to allow me to tell the robot to drive to a point, using odometry information. This is quite a complex task, as it involves moving the robot in two dimensions while being efficient.</p> <h2 id="basic-movement"> <a href="#basic-movement" class="anchor-heading"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#link"></use></svg></a> Basic Movement </h2> <p>Once you know the position of the robot and where you want to move, the challenge is to actually move there. Here is a very simple algorithm to drive to a point:</p> <ol> <li>Calculate angle to target</li> <li>Turn to face the target</li> <li>Calculate distance to target</li> <li>Move distance to reach target</li> </ol> <p>While this algorithm works decently well, it is quite slow and is not able to dynamically adjust while on-course. I instead wanted to make an algorithm that would curve toward the target, and calculate course adjustments on the fly.</p> <h3 id="pid-to-heading-and-distance"> <a href="#pid-to-heading-and-distance" class="anchor-heading"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#link"></use></svg></a> PID to Heading and Distance </h3> <p>The first algorithm I tried was PID. The distance and angle to the target would be sent to 2 PID controllers, and then the outputs would be combined. There were two problems with this method.</p> <p>The first was that the algorithm had to be terminated when the robot reached the general vicinity of the target, or else the robot would start having a spasm. This is because the PID needs to have a negative input signal to be able to back up and settle.</p> <p>However, when calculating distance to a point (using Pythagoras), you can’t know when you overshoot the target. Therefore, the robot could only move forward, so when it reaches <strong>and overshoots</strong> the target, the angle to the target flips 180 degrees and the distance PID goes full throttle.</p> <p>The second problem with this method is that it is not the most efficient. If the robot was perpendicular to the target, the distance PID would output full power, even though moving forward is the wrong thing to do.</p> <p><img src="images/4c657dbc37e8ba9aa90ca55b61b76f05335459d1.png" alt="" /></p> <p>Instead, I wanted an algorithm that prioritized turning over moving, and that only moves when doing so would make the robot get nearer to the target.</p> <h2 id="adaptive-pid-seeking"> <a href="#adaptive-pid-seeking" class="anchor-heading"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#link"></use></svg></a> Adaptive PID Seeking </h2> <p>I posed this question: “If the robot is locked to its current heading, so it can only move forward/backward, how can it move in a straight line to get closest to the point as possible?”.</p> <p>If the robot was perpendicular to the target, the answer would be 0. But as the robot rotates to face the target, the answer becomes more and more. Here are some images illustrating the question (the answer is the length of the red line):</p> <p><img src="images/d540e20cfe7ba1395aed7a1ecdab796141a108c0.png" alt="" /></p> <p>After some research and help, I was able to implement the math for this. When doing distance PID on the output of these calculations, the robot was able to move much more efficiently. I also had to implement some logic to be able to drive backward.</p> <p>The reason this algorithm works great for settling is that if I turn off the angle PID when the robot is a certain distance away from the target, the adaptive distance PID brings the robot to a settled stop, giving a negative signal to back up.</p> <p>To test this algorithm, I made a javascript simulation. You can see how the robot prefers turning over driving, and how it settles smoothly:</p> <object id="demoBorder" width="100%" height="300" data="demos/adaptiveSeek.html"> ![](images/479e47a7761f01d48f5c41f49bfbaeaf4f75f1c8.gif) </object> <h2 id="settling"> <a href="#settling" class="anchor-heading"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#link"></use></svg></a> Settling </h2> <p>Every single autonomous motion has a settling period. However, I wanted the settling to be customizable for every single command. I wanted to be able to settle a few different ways:</p> <ul> <li>All PID controllers come to a rest</li> <li>All PID controllers get to some margin of error</li> <li>The robot gets to a certain requirement, such as a certain distance from a point or a certain angle</li> </ul> <p>To do this, I created a parameter in each movement function that accepts a special kind of function called a <code class="language-plaintext highlighter-rouge">Settler</code>. Every loop, the movement function will ask the settler “am I settled yet?” and then the function will return true when it’s conditions are met.</p> <p>Here is the lib7842 implementation of a <code class="language-plaintext highlighter-rouge">Settler</code>:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * Function that returns true to end chassis movement. Used to implement different settling methods.
 */</span>
<span class="k">using</span> <span class="n">Settler</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">(</span><span class="k">const</span> <span class="n">OdomController</span><span class="o">&amp;</span> <span class="n">odom</span><span class="p">)</span><span class="o">&gt;</span><span class="p">;</span>
</code></pre></div></div> <p>Then, I created a few default settling functions and added the functionality to generate new settling functions on the fly. For example, here is a command with a settler that waits for all the PID controllers to settle.</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">driveToPoint</span><span class="p">({</span><span class="mi">1</span><span class="n">_ft</span><span class="p">,</span> <span class="mi">1</span><span class="n">_ft</span><span class="p">},</span> <span class="mi">1</span><span class="p">,</span> <span class="n">driveSettle</span><span class="p">);</span>
</code></pre></div></div> <p>If I wanted to make the robot exit the movement when it was 4 inches away from the target, I could use a distance-based settler.</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">driveToPoint</span><span class="p">({</span><span class="mi">1</span><span class="n">_ft</span><span class="p">,</span> <span class="mi">1</span><span class="n">_ft</span><span class="p">},</span> <span class="mi">1</span><span class="p">,</span> <span class="n">makeSettle</span><span class="p">(</span><span class="mi">4</span><span class="n">_in</span><span class="p">));</span>
</code></pre></div></div> <p>Here are some examples of settler creators:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * Make a Settler that exits when angle error is within given range
 * @param angle The angle error threshold
 */</span>
<span class="k">static</span> <span class="n">Settler</span> <span class="nf">makeSettler</span><span class="p">(</span><span class="k">const</span> <span class="n">QAngle</span><span class="o">&amp;</span> <span class="n">angle</span><span class="p">);</span>

<span class="cm">/**
 * Make a Settler that exits when distance error is within given range
 * @param distance The distance error threshold
 */</span>
<span class="k">static</span> <span class="n">Settler</span> <span class="nf">makeSettler</span><span class="p">(</span><span class="k">const</span> <span class="n">QLength</span><span class="o">&amp;</span> <span class="n">distance</span><span class="p">);</span>
</code></pre></div></div> <h2 id="turning"> <a href="#turning" class="anchor-heading"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#link"></use></svg></a> Turning </h2> <p>All turning is essentially the same motion. The only difference with all possible turns is the <strong>goal calculation</strong> and <strong>movement method</strong> (point, pivot, or arc). I wanted to write only one turning algorithm, and have all the implementations plug-in.</p> <p>Thus I used the same modular function pattern as the settling system and added parameters in the turning function to fulfill the angle calculation and movement method. Here are a few examples of a turn command:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">turn</span><span class="p">(</span><span class="n">makeAngle</span><span class="p">({</span><span class="mi">1</span><span class="n">_ft</span><span class="p">,</span> <span class="mi">1</span><span class="n">_ft</span><span class="p">}),</span> <span class="n">pointTurn</span><span class="p">,</span> <span class="n">turnSettle</span><span class="p">);</span>
<span class="n">turn</span><span class="p">(</span><span class="n">makeAngle</span><span class="p">(</span><span class="mi">90</span><span class="n">_deg</span><span class="p">),</span> <span class="n">leftPivot</span><span class="p">,</span> <span class="n">makeSettle</span><span class="p">(</span><span class="mi">5</span><span class="n">_deg</span><span class="p">));</span>
</code></pre></div></div> <p>Here is the lib7842 implementation of <code class="language-plaintext highlighter-rouge">Turner</code> and <code class="language-plaintext highlighter-rouge">AngleCalculator</code>:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * Function that accepts a turning velocity and controls execution to the chassis. Used to implement
 * a point or pivot turn.
 */</span>
<span class="k">using</span> <span class="n">Turner</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="n">ChassisModel</span><span class="o">&amp;</span> <span class="n">model</span><span class="p">,</span> <span class="kt">double</span> <span class="n">vel</span><span class="p">)</span><span class="o">&gt;</span><span class="p">;</span>

<span class="cm">/**
 * Function that returns an angle for the chassis to seek. Examples can be an AngleCalculator that
 * returns the angle to a point, or an angle to an absolute angle.
 */</span>
<span class="k">using</span> <span class="n">AngleCalculator</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="n">QAngle</span><span class="p">(</span><span class="k">const</span> <span class="n">OdomController</span><span class="o">&amp;</span> <span class="n">odom</span><span class="p">)</span><span class="o">&gt;</span><span class="p">;</span>
</code></pre></div></div> <p>Here is the basis <code class="language-plaintext highlighter-rouge">turn</code> function that <strong>all</strong> other turns use:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * Turn the chassis using the given AngleCalculator
 *
 * @param angleCalculator The angle calculator
 * @param turner          The turner
 * @param settler         The settler
 */</span>
<span class="k">virtual</span> <span class="kt">void</span> <span class="nf">turn</span><span class="p">(</span><span class="k">const</span> <span class="n">AngleCalculator</span><span class="o">&amp;</span> <span class="n">angleCalculator</span><span class="p">,</span> <span class="k">const</span> <span class="n">Turner</span><span class="o">&amp;</span> <span class="n">turner</span> <span class="o">=</span> <span class="n">pointTurn</span><span class="p">,</span>
                <span class="k">const</span> <span class="n">Settler</span><span class="o">&amp;</span> <span class="n">settler</span> <span class="o">=</span> <span class="n">defaultTurnSettler</span><span class="p">);</span>
</code></pre></div></div> <p>Here are a few <code class="language-plaintext highlighter-rouge">AngleCalculator</code> creators:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * Make an AngleCalculator that seeks a given absolute angle
 *
 * @param angle The angle
 */</span>
<span class="k">static</span> <span class="n">AngleCalculator</span> <span class="nf">makeAngleCalculator</span><span class="p">(</span><span class="k">const</span> <span class="n">QAngle</span><span class="o">&amp;</span> <span class="n">angle</span><span class="p">);</span>

<span class="cm">/**
 * Make an AngleCaclulator that seeks a given point.
 *
 * @param point The point
 */</span>
<span class="k">static</span> <span class="n">AngleCalculator</span> <span class="nf">makeAngleCalculator</span><span class="p">(</span><span class="k">const</span> <span class="n">Vector</span><span class="o">&amp;</span> <span class="n">point</span><span class="p">);</span>
</code></pre></div></div> <p>These <code class="language-plaintext highlighter-rouge">AngleCalculator</code>s will provide the foundation on which to build X-Drive control on.</p> <p>I also made a few helper functions to provide more expressive turning commands: <code class="language-plaintext highlighter-rouge">turnToAngle(angle)</code>, <code class="language-plaintext highlighter-rouge">turnAngle(angle)</code>, and <code class="language-plaintext highlighter-rouge">turnToPoint(point)</code>, which all just call <code class="language-plaintext highlighter-rouge">turn(angleCalc)</code> internally.</p> <h2 id="odomcontroller-code"> <a href="#odomcontroller-code" class="anchor-heading"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#link"></use></svg></a> OdomController Code </h2> <p>Here is the entire <code class="language-plaintext highlighter-rouge">OdomController</code> header:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * Function that returns true to end chassis movement. Used to implement different settling methods.
 */</span>
<span class="k">using</span> <span class="n">Settler</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">(</span><span class="k">const</span> <span class="n">OdomController</span><span class="o">&amp;</span> <span class="n">odom</span><span class="p">)</span><span class="o">&gt;</span><span class="p">;</span>

<span class="cm">/**
 * Function that accepts a turning velocity and controls execution to the chassis. Used to implement
 * a point or pivot turn.
 */</span>
<span class="k">using</span> <span class="n">Turner</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="n">ChassisModel</span><span class="o">&amp;</span> <span class="n">model</span><span class="p">,</span> <span class="kt">double</span> <span class="n">vel</span><span class="p">)</span><span class="o">&gt;</span><span class="p">;</span>

<span class="cm">/**
 * Function that returns an angle for the chassis to seek. Examples can be an AngleCalculator that
 * returns the angle to a point, or an angle to an absolute angle.
 */</span>
<span class="k">using</span> <span class="n">AngleCalculator</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="n">QAngle</span><span class="p">(</span><span class="k">const</span> <span class="n">OdomController</span><span class="o">&amp;</span> <span class="n">odom</span><span class="p">)</span><span class="o">&gt;</span><span class="p">;</span>

<span class="cm">/**
 * Odometry motion controller for skid-steer chassis.
 */</span>
<span class="k">class</span> <span class="nc">OdomController</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="cm">/**
   * OdomController. Implements chassis movement algorithms
   *
   * @param imodel              The chassis model
   * @param iodometry           The chassis odometry
   * @param idistanceController The distance pid controller
   * @param iturnController     The turning pid controller
   * @param iangleController    The angle pid controller, used to keep distance driving straight
   * @param isettleRadius       The radius from the target point to give up angle correction
   * @param itimeUtil           The time utility
   */</span>
  <span class="n">OdomController</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">ChassisModel</span><span class="o">&gt;&amp;</span> <span class="n">imodel</span><span class="p">,</span>
                 <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Odometry</span><span class="o">&gt;&amp;</span> <span class="n">iodometry</span><span class="p">,</span>
                 <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IterativePosPIDController</span><span class="o">&gt;</span> <span class="n">idistanceController</span><span class="p">,</span>
                 <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IterativePosPIDController</span><span class="o">&gt;</span> <span class="n">iturnController</span><span class="p">,</span>
                 <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IterativePosPIDController</span><span class="o">&gt;</span> <span class="n">iangleController</span><span class="p">,</span>
                 <span class="k">const</span> <span class="n">QLength</span><span class="o">&amp;</span> <span class="n">isettleRadius</span><span class="p">,</span> <span class="k">const</span> <span class="n">TimeUtil</span><span class="o">&amp;</span> <span class="n">itimeUtil</span><span class="p">);</span>

  <span class="k">virtual</span> <span class="o">~</span><span class="n">OdomController</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>

  <span class="cm">/**
   * Turn the chassis using the given AngleCalculator
   *
   * @param angleCalculator The angle calculator
   * @param turner          The turner
   * @param settler         The settler
   */</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">turn</span><span class="p">(</span><span class="k">const</span> <span class="n">AngleCalculator</span><span class="o">&amp;</span> <span class="n">angleCalculator</span><span class="p">,</span> <span class="k">const</span> <span class="n">Turner</span><span class="o">&amp;</span> <span class="n">turner</span> <span class="o">=</span> <span class="n">pointTurn</span><span class="p">,</span>
                    <span class="k">const</span> <span class="n">Settler</span><span class="o">&amp;</span> <span class="n">settler</span> <span class="o">=</span> <span class="n">defaultTurnSettler</span><span class="p">);</span>

  <span class="cm">/**
   * Turn the chassis to face an absolute angle
   *
   * @param angle   The angle
   * @param turner  The turner
   * @param settler The settler
   */</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">turnToAngle</span><span class="p">(</span><span class="k">const</span> <span class="n">QAngle</span><span class="o">&amp;</span> <span class="n">angle</span><span class="p">,</span> <span class="k">const</span> <span class="n">Turner</span><span class="o">&amp;</span> <span class="n">turner</span> <span class="o">=</span> <span class="n">pointTurn</span><span class="p">,</span>
                           <span class="k">const</span> <span class="n">Settler</span><span class="o">&amp;</span> <span class="n">settler</span> <span class="o">=</span> <span class="n">defaultTurnSettler</span><span class="p">);</span>

  <span class="cm">/**
   * Turn the chassis to face a relative angle
   *
   * @param angle   The angle
   * @param turner  The turner
   * @param settler The settler
   */</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">turnAngle</span><span class="p">(</span><span class="k">const</span> <span class="n">QAngle</span><span class="o">&amp;</span> <span class="n">angle</span><span class="p">,</span> <span class="k">const</span> <span class="n">Turner</span><span class="o">&amp;</span> <span class="n">turner</span> <span class="o">=</span> <span class="n">pointTurn</span><span class="p">,</span>
                         <span class="k">const</span> <span class="n">Settler</span><span class="o">&amp;</span> <span class="n">settler</span> <span class="o">=</span> <span class="n">defaultTurnSettler</span><span class="p">);</span>

  <span class="cm">/**
   * Turn the chassis to face a point
   *
   * @param point   The point
   * @param turner  The turner
   * @param settler The settler
   */</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">turnToPoint</span><span class="p">(</span><span class="k">const</span> <span class="n">Vector</span><span class="o">&amp;</span> <span class="n">point</span><span class="p">,</span> <span class="k">const</span> <span class="n">Turner</span><span class="o">&amp;</span> <span class="n">turner</span> <span class="o">=</span> <span class="n">pointTurn</span><span class="p">,</span>
                           <span class="k">const</span> <span class="n">Settler</span><span class="o">&amp;</span> <span class="n">settler</span> <span class="o">=</span> <span class="n">defaultTurnSettler</span><span class="p">);</span>

  <span class="cm">/**
   * Drive a distance while correcting angle using an AngleCalculator
   *
   * @param distance        The distance
   * @param angleCalculator The angle calculator
   * @param turnScale       The turn scale
   * @param settler         The settler
   */</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">moveDistanceAtAngle</span><span class="p">(</span><span class="k">const</span> <span class="n">QLength</span><span class="o">&amp;</span> <span class="n">distance</span><span class="p">,</span> <span class="k">const</span> <span class="n">AngleCalculator</span><span class="o">&amp;</span> <span class="n">angleCalculator</span><span class="p">,</span>
                                   <span class="kt">double</span> <span class="n">turnScale</span><span class="p">,</span>
                                   <span class="k">const</span> <span class="n">Settler</span><span class="o">&amp;</span> <span class="n">settler</span> <span class="o">=</span> <span class="n">defaultDriveAngleSettler</span><span class="p">);</span>

  <span class="cm">/**
   * Drive a distance while maintaining starting angle
   *
   * @param distance The distance
   * @param settler  The settler
   */</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">moveDistance</span><span class="p">(</span><span class="k">const</span> <span class="n">QLength</span><span class="o">&amp;</span> <span class="n">distance</span><span class="p">,</span>
                            <span class="k">const</span> <span class="n">Settler</span><span class="o">&amp;</span> <span class="n">settler</span> <span class="o">=</span> <span class="n">defaultDriveAngleSettler</span><span class="p">);</span>

  <span class="cm">/**
   * Drive to a point using custom point seeking
   *
   * @param targetPoint The target point
   * @param turnScale   The turn scale used to control the priority of turning over driving. A
   *                    higher value will make the robot turn to face the point sooner
   * @param settler     The settler
   */</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">driveToPoint</span><span class="p">(</span><span class="k">const</span> <span class="n">Vector</span><span class="o">&amp;</span> <span class="n">targetPoint</span><span class="p">,</span> <span class="kt">double</span> <span class="n">turnScale</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
                            <span class="k">const</span> <span class="n">Settler</span><span class="o">&amp;</span> <span class="n">settler</span> <span class="o">=</span> <span class="n">defaultDriveAngleSettler</span><span class="p">);</span>

  <span class="cm">/**
   * Drive to a point using simple point seeking
   *
   * @param targetPoint The target point
   * @param turnScale   The turn scale used to control the priority of turning over driving. A
   *                    higher value will make the robot turn to face the point sooner
   * @param settler     The settler
   */</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">driveToPoint2</span><span class="p">(</span><span class="k">const</span> <span class="n">Vector</span><span class="o">&amp;</span> <span class="n">targetPoint</span><span class="p">,</span> <span class="kt">double</span> <span class="n">turnScale</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
                             <span class="k">const</span> <span class="n">Settler</span><span class="o">&amp;</span> <span class="n">settler</span> <span class="o">=</span> <span class="n">defaultDriveAngleSettler</span><span class="p">);</span>

  <span class="cm">/**
   * A Settler that is used for turning which uses the turning pid's isSettled() method
   */</span>
  <span class="k">static</span> <span class="kt">bool</span> <span class="n">defaultTurnSettler</span><span class="p">(</span><span class="k">const</span> <span class="n">OdomController</span><span class="o">&amp;</span> <span class="n">odom</span><span class="p">);</span>

  <span class="cm">/**
   * A Settler that is used for driving which uses the distance pid's isSettled() method
   */</span>
  <span class="k">static</span> <span class="kt">bool</span> <span class="n">defaultDriveSettler</span><span class="p">(</span><span class="k">const</span> <span class="n">OdomController</span><span class="o">&amp;</span> <span class="n">odom</span><span class="p">);</span>

  <span class="cm">/**
   * A Settler that is used for driving which uses the distance and angle pid's isSettled() method
   */</span>
  <span class="k">static</span> <span class="kt">bool</span> <span class="n">defaultDriveAngleSettler</span><span class="p">(</span><span class="k">const</span> <span class="n">OdomController</span><span class="o">&amp;</span> <span class="n">odom</span><span class="p">);</span>

  <span class="cm">/**
   * A Turner that executes a point turn which turns in place. Used as default for turn functions
   */</span>
  <span class="k">static</span> <span class="kt">void</span> <span class="n">pointTurn</span><span class="p">(</span><span class="n">ChassisModel</span><span class="o">&amp;</span> <span class="n">model</span><span class="p">,</span> <span class="kt">double</span> <span class="n">vel</span><span class="p">);</span>

  <span class="cm">/**
   * A Turner that executes a left pivot, meaning it only moves the left motors.
   */</span>
  <span class="k">static</span> <span class="kt">void</span> <span class="n">leftPivot</span><span class="p">(</span><span class="n">ChassisModel</span><span class="o">&amp;</span> <span class="n">model</span><span class="p">,</span> <span class="kt">double</span> <span class="n">vel</span><span class="p">);</span>

  <span class="cm">/**
   * A Turner that executes a right pivot, meaning it only moves the right motors.
   */</span>
  <span class="k">static</span> <span class="kt">void</span> <span class="n">rightPivot</span><span class="p">(</span><span class="n">ChassisModel</span><span class="o">&amp;</span> <span class="n">model</span><span class="p">,</span> <span class="kt">double</span> <span class="n">vel</span><span class="p">);</span>

  <span class="cm">/**
   * Make a Settler that exits when angle error is within given range
   * @param angle The angle error threshold
   */</span>
  <span class="k">static</span> <span class="n">Settler</span> <span class="n">makeSettler</span><span class="p">(</span><span class="k">const</span> <span class="n">QAngle</span><span class="o">&amp;</span> <span class="n">angle</span><span class="p">);</span>

  <span class="cm">/**
   * Make a Settler that exits when distance error is within given range
   * @param distance The distance error threshold
   */</span>
  <span class="k">static</span> <span class="n">Settler</span> <span class="n">makeSettler</span><span class="p">(</span><span class="k">const</span> <span class="n">QLength</span><span class="o">&amp;</span> <span class="n">distance</span><span class="p">);</span>

  <span class="cm">/**
   * Make a Settler that exits when both angle and distance error is within given range.
   * @param angle The angle error threshold
   * @param distance The distance error threshold
   */</span>
  <span class="k">static</span> <span class="n">Settler</span> <span class="n">makeSettler</span><span class="p">(</span><span class="k">const</span> <span class="n">QLength</span><span class="o">&amp;</span> <span class="n">distance</span><span class="p">,</span> <span class="k">const</span> <span class="n">QAngle</span><span class="o">&amp;</span> <span class="n">angle</span><span class="p">);</span>

  <span class="cm">/**
   * Make an AngleCalculator that seeks a given absolute angle
   *
   * @param angle The angle
   */</span>
  <span class="k">static</span> <span class="n">AngleCalculator</span> <span class="n">makeAngleCalculator</span><span class="p">(</span><span class="k">const</span> <span class="n">QAngle</span><span class="o">&amp;</span> <span class="n">angle</span><span class="p">);</span>

  <span class="cm">/**
   * Make an AngleCaclulator that seeks a given point.
   *
   * @param point The point
   */</span>
  <span class="k">static</span> <span class="n">AngleCalculator</span> <span class="n">makeAngleCalculator</span><span class="p">(</span><span class="k">const</span> <span class="n">Vector</span><span class="o">&amp;</span> <span class="n">point</span><span class="p">);</span>

  <span class="cm">/**
   * Make an AngleCaclulator that returns a constant error. The default settler needs to be changed
   * for a command using this calculator to settle.
   *
   * @param  error The error
   * @return The angle calculator.
   */</span>
  <span class="k">static</span> <span class="n">AngleCalculator</span> <span class="n">makeAngleCalculator</span><span class="p">(</span><span class="kt">double</span> <span class="n">error</span><span class="p">);</span>

  <span class="cm">/**
   * Make an AngleCalculator that does nothing
   */</span>
  <span class="k">static</span> <span class="n">AngleCalculator</span> <span class="n">makeAngleCalculator</span><span class="p">();</span>

  <span class="cm">/**
   * Get the odometry state.
   */</span>
  <span class="n">State</span> <span class="n">getState</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/**
   * Calculate distance from the chassis to the point
   */</span>
  <span class="n">QLength</span> <span class="n">distanceToPoint</span><span class="p">(</span><span class="k">const</span> <span class="n">Vector</span><span class="o">&amp;</span> <span class="n">point</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/**
   * Calculate angle from the chassis to the point
   */</span>
  <span class="n">QAngle</span> <span class="n">angleToPoint</span><span class="p">(</span><span class="k">const</span> <span class="n">Vector</span><span class="o">&amp;</span> <span class="n">point</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

<span class="nl">protected:</span>
  <span class="cm">/**
   * Reset the pid controllers, used before every motion
   */</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">resetPid</span><span class="p">();</span>

  <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">ChassisModel</span><span class="o">&gt;</span> <span class="n">model</span> <span class="p">{</span><span class="nb">nullptr</span><span class="p">};</span>
  <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Odometry</span><span class="o">&gt;</span> <span class="n">odometry</span> <span class="p">{</span><span class="nb">nullptr</span><span class="p">};</span>
  <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IterativePosPIDController</span><span class="o">&gt;</span> <span class="n">distanceController</span> <span class="p">{</span><span class="nb">nullptr</span><span class="p">};</span>
  <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IterativePosPIDController</span><span class="o">&gt;</span> <span class="n">angleController</span> <span class="p">{</span><span class="nb">nullptr</span><span class="p">};</span>
  <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IterativePosPIDController</span><span class="o">&gt;</span> <span class="n">turnController</span> <span class="p">{</span><span class="nb">nullptr</span><span class="p">};</span>
  <span class="k">const</span> <span class="n">QLength</span> <span class="n">settleRadius</span><span class="p">;</span>
  <span class="n">TimeUtil</span> <span class="n">timeUtil</span><span class="p">;</span>

  <span class="n">QAngle</span> <span class="n">angleErr</span> <span class="o">=</span> <span class="mi">0</span><span class="n">_deg</span><span class="p">;</span>
  <span class="n">QLength</span> <span class="n">distanceErr</span> <span class="o">=</span> <span class="mi">0</span><span class="n">_in</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div> <p>Here is the motion algorithm to drive to a point using the adaptive seeking method:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="n">OdomController</span><span class="o">::</span><span class="n">driveToPoint</span><span class="p">(</span><span class="k">const</span> <span class="n">Vector</span><span class="o">&amp;</span> <span class="n">targetPoint</span><span class="p">,</span> <span class="kt">double</span> <span class="n">turnScale</span><span class="p">,</span>
                                  <span class="k">const</span> <span class="n">Settler</span><span class="o">&amp;</span> <span class="n">settler</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">resetPid</span><span class="p">();</span>
  <span class="k">auto</span> <span class="n">rate</span> <span class="o">=</span> <span class="n">timeUtil</span><span class="p">.</span><span class="n">getRate</span><span class="p">();</span>
  <span class="k">do</span> <span class="p">{</span>
    <span class="n">State</span> <span class="n">state</span> <span class="o">=</span> <span class="n">getState</span><span class="p">();</span>
    <span class="n">Vector</span> <span class="n">closestPoint</span> <span class="o">=</span> <span class="n">closest</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">targetPoint</span><span class="p">);</span>

    <span class="n">QAngle</span> <span class="n">angleToClose</span> <span class="o">=</span> <span class="n">state</span><span class="p">.</span><span class="n">angleTo</span><span class="p">(</span><span class="n">closestPoint</span><span class="p">);</span>
    <span class="n">QAngle</span> <span class="n">angleToTarget</span> <span class="o">=</span> <span class="n">state</span><span class="p">.</span><span class="n">angleTo</span><span class="p">(</span><span class="n">targetPoint</span><span class="p">);</span>

    <span class="n">QLength</span> <span class="n">distanceToClose</span> <span class="o">=</span> <span class="n">state</span><span class="p">.</span><span class="n">distTo</span><span class="p">(</span><span class="n">closestPoint</span><span class="p">);</span>
    <span class="n">QLength</span> <span class="n">distanceToTarget</span> <span class="o">=</span> <span class="n">state</span><span class="p">.</span><span class="n">distTo</span><span class="p">(</span><span class="n">targetPoint</span><span class="p">);</span>

    <span class="c1">// go backwards</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">angleToClose</span><span class="p">.</span><span class="n">abs</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="mi">90</span><span class="n">_deg</span><span class="p">)</span> <span class="n">distanceToClose</span> <span class="o">=</span> <span class="o">-</span><span class="n">distanceToClose</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">distanceToTarget</span><span class="p">.</span><span class="n">abs</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">settleRadius</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">angleErr</span> <span class="o">=</span> <span class="mi">0</span><span class="n">_deg</span><span class="p">;</span>
      <span class="c1">// used for settling</span>
      <span class="n">distanceErr</span> <span class="o">=</span> <span class="n">distanceToClose</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="n">angleErr</span> <span class="o">=</span> <span class="n">angleToTarget</span><span class="p">;</span>
      <span class="c1">// used for settling</span>
      <span class="n">distanceErr</span> <span class="o">=</span> <span class="n">distanceToTarget</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// rotate angle to be +- 90</span>
    <span class="n">angleErr</span> <span class="o">=</span> <span class="n">rotateAngle90</span><span class="p">(</span><span class="n">angleErr</span><span class="p">);</span>

    <span class="kt">double</span> <span class="n">angleVel</span> <span class="o">=</span> <span class="n">angleController</span><span class="o">-&gt;</span><span class="n">step</span><span class="p">(</span><span class="o">-</span><span class="n">angleErr</span><span class="p">.</span><span class="n">convert</span><span class="p">(</span><span class="n">degree</span><span class="p">));</span>
    <span class="kt">double</span> <span class="n">distanceVel</span> <span class="o">=</span> <span class="n">distanceController</span><span class="o">-&gt;</span><span class="n">step</span><span class="p">(</span><span class="o">-</span><span class="n">distanceToClose</span><span class="p">.</span><span class="n">convert</span><span class="p">(</span><span class="n">millimeter</span><span class="p">));</span>

    <span class="n">driveVector</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">distanceVel</span><span class="p">,</span> <span class="n">angleVel</span> <span class="o">*</span> <span class="n">turnScale</span><span class="p">);</span>
    <span class="n">rate</span><span class="o">-&gt;</span><span class="n">delayUntil</span><span class="p">(</span><span class="mi">10</span><span class="n">_ms</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">settler</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">));</span>

  <span class="n">driveVector</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> </article> <hr> <footer role="contentinfo"> <p class="text-small text-grey-dk-000 mb-0">Copyright &copy; 2020-2021</p> </footer> </div> </div> </div> </div> </body> </html> <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
