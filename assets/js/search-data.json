{
  
  
  "0": {
    "title": "",
    "content": "404 . Page not found :( . The requested page could not be found. .",
    "url": "https://theol0403.github.io/7842B-Journal/404.html",
    "relUrl": "/404.html"
  }
  ,"1": {
    "title": "Archive",
    "content": ". . {% assign posts = site.posts | where: &quot;parent&quot;, &quot;Archive&quot; %} {% for post in posts %} {{ post.title }} - {{ post.date | date_to_long_string }} | {% endfor %} .",
    "url": "https://theol0403.github.io/7842B-Journal/archive",
    "relUrl": "/archive"
  }
  ,"2": {
    "title": "Build",
    "content": "Build Journal . I’m Sawyer McClellan, and this is my digital build journal for the 2020/2021 Change Up season. . My primary role on the team is to design and build the robot and am the main driver. . . . {% assign posts = site.posts | where: &quot;parent&quot;, &quot;Build&quot; %} {% for post in posts %} {{ post.title }} - {{ post.date | date_to_long_string }} | {% endfor %} .",
    "url": "https://theol0403.github.io/7842B-Journal/build",
    "relUrl": "/build"
  }
  ,"3": {
    "title": "Home",
    "content": "7842B Digital Engineering Journal . Welcome to the Digital Engineering Journal for VEX team 7842B in the Change Up season. . . We are a two-person team, consisting of: . Sawyer McClellan - Builder | Theo Lemay - Programmer | . This is a joint digital journal, with sections for building and programming. . Build Journal Programming Journal . Parts of the code used for the robot is built on previous years work, so relevant journal entries are kept in archive. . Tower Takeover Archive . . All Posts . . {% for post in site.posts %} {{ post.title }} - {{ post.date | date_to_long_string }} | {% endfor %} .",
    "url": "https://theol0403.github.io/7842B-Journal/",
    "relUrl": "/"
  }
  ,"4": {
    "title": "Programming",
    "content": "Programming Journal . Hello! I’m Theo Lemay, and this is my digital programming journal for the 2020/2021 Change Up season. . My primary role on the team is to design driver controls, design autonomous motion control algorithms, and design and develop autonomous skills routines. I also assist with building and driving. . This season, I have invested the majority of my time on three major tasks: . Intake Control . Develop an intuitive and versatile driver control scheme for the robot intakes that make it easy to drive. | Implement a statemachine controller that combines driver and sensor input to achieve smooth and intuitive ball handling. | Use sensors to automate features like autopooping, which is the automatic disposal of unwanted balls. | . Intake Control . Motion Control . Develop smooth, repeatable, and powerful motion algorithms, for fast and optimal navigation during autonomous. | Use sensors to improve reliability, like localization, vision seeking, and velocity control. | . Motion Control . Programming Skills . Design and implement programming skills runs that are consistent and fast. | . Programming Skills . . . {% assign posts = site.posts | where: &quot;parent&quot;, &quot;Programming&quot; %} {% for post in posts %} {{ post.title }} - {{ post.date | date_to_long_string }} | {% endfor %} .",
    "url": "https://theol0403.github.io/7842B-Journal/programming",
    "relUrl": "/programming"
  }
  ,"5": {
    "title": "Example Entry",
    "content": "This a test of all markdown possibilities: . . h1 Heading 1 . h2 Heading 2 . h3 Heading 3 . h4 Heading 4 . h5 Heading 5 . h6 Heading 6 . . Horizontal Rules . . . Emphasis . This is bold text . This is bold text . This is italic text . This is italic text . Strikethrough . . Links . This is an example inline link. . This is a footnote link . . Blockquotes . Blockquotes can also be nested… . …by using additional greater-than signs right next to each other… . …or with spaces between arrows. . . Lists . Unordered . Create a list by starting a line with +, -, or * | Sub-lists are made by indenting 2 spaces: Marker character change forces new list start: Ac tristique libero volutpat at | Facilisis in pretium nisl aliquet | Nulla volutpat aliquam velit | . | . | Very easy! | . Ordered . Numers in sequence . Lorem ipsum dolor sit amet | Consectetur adipiscing elit | Integer molestie lorem at massa | Numers not in sequence . You can use sequential numbers… | …or keep all the numbers as 1. | . Images . . Like links, Images also have a footnote style syntax . With a reference later in the document defining the URL location: . . Tables . Option Description . data | path to data files to supply the data that will be passed into templates. | . engine | engine to be used for processing templates. Handlebars is the default. | . ext | extension to be used for dest files. | . Right aligned columns . Option Description . data | path to data files to supply the data that will be passed into templates. | . engine | engine to be used for processing templates. Handlebars is the default. | . ext | extension to be used for dest files. | . . Code . Inline code . Indented code . // Some comments line 1 of code line 2 of code line 3 of code . Block code “fences” . Sample text here... . Syntax highlighting . var foo = function (bar) { return bar++; }; console.log(foo(5)); . .",
    "url": "https://theol0403.github.io/7842B-Journal/2021-03-31/example/",
    "relUrl": "/2021-03-31/example/"
  }
  ,"6": {
    "title": "Skills",
    "content": "I need to find the best programming skills routine. Considerations: . point turns are slow and prone to error | reducing the number of separate motions and optimizing for long, smooth motions is ideal | the locations where the robot can dispose blue balls (poop) must be carefully selected to not collide with other balls | goals can be used to realign the robot | . Old Routine . Previously, our routine was only designed to score a maximum of 122 points (out of 126), purposefully excluding 4 of the balls. It looked something like this: . . Where B is the start, E is the end, and green is point turns. In this run, there are 13 point turns. .",
    "url": "https://theol0403.github.io/7842B-Journal/skills",
    "relUrl": "/skills"
  }
  ,"7": {
    "title": "Intake/Rollers Design",
    "content": "Intake/Rollers Design . Different Parts . Front Intakes . The robot was built so that the intakes could fold out to extend the reach of the robot into the goals. This was done by using nilocks and strand-offs. Elastics are used to pull the intakes to the front and into position. The intakes rotate in until they hit the stopper. The stopper is made to be easily changed for the right amount of compression on the ball. The intakes run at 200 rpm. . . Back Rollers . The robot has rollers at the back that are spaced apart so that we can get rid of the balls out the back. . . The robot uses 2 motors for the rollers that move up and shoot the balls. Since there are 4 rollers each motor controls 2 rollers. . You can see the 4 rollers in his image. . However, since our robot gets rid of the wrong-colored balls out the back which means they need to be able to spin opposite directions – either spit out the ball or send it up to score with. Therefore, the back rollers must be on different motors. So, each one of the back rollers are connected to one of the front rollers but the front and back need to go opposite directions to move the ball up. So, to run two rollers opposite directions with one motor we made a gearbox to reverse the rotation. The rollers that move the ball up or out the back run at 200 Rpm and the one that shoots them runs at 600 Rpm. .",
    "url": "https://theol0403.github.io/7842B-Journal/2021-02-07/Intakes/",
    "relUrl": "/2021-02-07/Intakes/"
  }
  ,"8": {
    "title": "Robot V1",
    "content": "",
    "url": "https://theol0403.github.io/7842B-Journal/2021-02-01/robot-v1/",
    "relUrl": "/2021-02-01/robot-v1/"
  }
  ,"9": {
    "title": "lib7842",
    "content": "What is lib7842? . lib7842 is a PROS library for advanced controls which is built around OkapiLib. It is designed to be a good example for advanced programming and a useful tool for competition. . I have been working of lib7842 since summer 2019, and plan on releasing it to the VEX community by summer 2020. I will use it for competition through the season, which will not only provide testing and experience, but also provide a direction and motivation for the library. . I have shared the library with some teams in the US who are part of TVA for testing and collaboration purposes. . What will lib7842 provide? . The core of lib7842 will be: . Fluent path generation API | Pure Pursuit path follower | Pure Pursuit X-Drive path follower | Odometry-based PID motion controller | Odometry-based PID X-Drive controller | Flexible GUI library | Vision sensor management and filtering | . There are other utilities and functionality in lib7842, but these are the main elements of it. . Programming Practices: . lib7842 is a full library that will be used by many VEX competitors. To deliver the best product possible, I am learning how to follow the best C++ coding standards and practices for lib7842. . Git Make a commit for every change made | Use imperative tense for commit messages | Use git flow for source and feature management | . | Formatting Format all code using clang-format | . | CI and Tests Tests need to be made for each public API | Each commit is compiled and tested by Azure Pipelines | CI Results V5 binary and template | Test results | Valgrind memory leak detector results | Callgrind profiler results | CppCheck static analysis | Codacity static analysis | Codefactor static analysis | . | . | . Commit Messages . Here is an example of lib7842 commit messages, which are intended to be as informative as possible: . .",
    "url": "https://theol0403.github.io/7842B-Journal/2019-11-28/lib7842/",
    "relUrl": "/2019-11-28/lib7842/"
  }
  ,"10": {
    "title": "Pure Pursuit",
    "content": "Pure pursuit is a path following algorithm. Using odometry information and a path, pure pursuit controls how the robot should move to follow the path. . Pure pursuit has a few advantages: . Motion profile capabilities: acceleration and velocity constraints | Expressive arcs and curves | Dynamic and feedback-based correction | . A great paper on adaptive pure pursuit can be found here. . How it works . Pure pursuit works by finding a lookahead on the path. It does this by finding the intersection of a circle of a given radius with the path. Then, the robot seeks the lookahead by calculating curvature and velocity to reach the lookahead. . . . Implementing Pure Pursuit . To test pursuit, I wrote a full simulation using javascript. I was able to implement all the logic and optimization in that controlled environment. Implementing algorithms in javascript is very useful, as it provides a visual way of testing the algorithm and the code can translate to C++ quite easily. This algorithm has been in progress since June 2019. . Here are the controls: . Ctrl + Right-click to place robot | Click to place node | Click and drag to move node | Right-click node to delete | Right-click and drag to delete selection | . Here are the sliders: . Sample resolution: how many points should be generated from the path formula | Smoothing constant: how smooth should the connections between segments be | Lookahead distance: how far along the path should the robot look | Code . The majority of the code currently in lib7842 is used for pure pursuit. This includes path representations, path creation and interpolation, path velocity generation (motion profile), as well as the actual path follower. . Here is an example code for pure pursuit: . auto path = SimplePath({odom-&gt;getState(), {0_ft, 0_ft}, {0_ft, 4_ft}}) .generate(1_mm) .smoothen(.001, 1e-10 * meter); follower.followPath(PathGenerator::generate(path, limits), false); .",
    "url": "https://theol0403.github.io/7842B-Journal/2019-11-25/pure-pursuit/",
    "relUrl": "/2019-11-25/pure-pursuit/"
  }
  ,"11": {
    "title": "Odom X Controller",
    "content": "Having an X-Drive allows for much more complex algorithms. Not only can it move in all directions, but it can move independently of heading. This allows the robot to drive while turning, which is very useful for competition. . As of writing this, none of my autonomous programs use any turn commands, because all the required turning is handled while driving. . Directional Drive . I have made a function that allows me to tell the robot to drive in a certain direction. Using this math I can tell the chassis to strafe at a certain direction and speed. . . Here is the lib7842 implementation of this functionality: . /** * Control the chassis movement for an XDrive using voltage. Strafes at the given voltage in the * given direction. Applies magnitude control to prioritize turning. Range of forward, yaw, and * strafe is +-1, but yaw may be outside of the range which prioritizes turning. * * @param model The chassis model * @param forward The forward voltage * @param yaw The yaw voltage * @param direction The direction */ void strafeVector(const std::shared_ptr&lt;XDriveModel&gt;&amp; model, double forward, double yaw, const QAngle&amp; direction); . PID Seeking . Driving to a point with an X-Drive is much easier than with a skid-steer drive. This is because the direction of the robot does not depend on the heading of the robot, which eliminates oscillation and other issues. . Driving to a point is as simple as using odometry to calculate the angle and distance to the target point. I then apply PID to the distance error to determine the speed at which the robot should be moving. . I can then use the above function to apply the PID output to the desired direction. Doing this, the robot will always move towards the target point, and it even handles settling really well. . Turning While Driving . Using the above calculations, turning while driving is quite easy to implement. I simply use an AngleCalculator to calculate the desired turning amount. I apply PID to the output of the AngleCalculator, and then combine that with the output of the movement command. . Using an AngleCalculator to calculate the desired angle is quite useful, as I can use it to tell the robot to face a point or angle while driving, as well as turn while driving. . Here is the lib7842 implementation of X-Drive movement: . void OdomXController::strafeToPoint(const Vector&amp; targetPoint, const AngleCalculator&amp; angleCalculator, double turnScale, const Settler&amp; settler) { resetPid(); auto rate = timeUtil.getRate(); do { State state = getState(); distanceErr = state.distTo(targetPoint); angleErr = angleCalculator(*this); QAngle angleToTarget = angleToPoint(targetPoint); double distanceVel = distanceController-&gt;step(-distanceErr.convert(millimeter)); double angleVel = angleController-&gt;step(-angleErr.convert(degree)); strafeVector(xModel, distanceVel, angleVel * turnScale, angleToTarget); rate-&gt;delayUntil(10_ms); } while (!settler(*this)); driveVector(xModel, 0, 0); } . OdomXController Code: . /** * Odometry motion controller for X-Base chassis. */ class OdomXController : public OdomController { public: /** * OdomXController. Implements chassis movement algorithms for the X drive. * * @param imodel The chassis model * @param iodometry The chassis odometry * @param idistanceController The distance pid controller * @param iturnController The turning pid controller * @param iangleController The angle pid controller, used to keep distance driving straight */ OdomXController(const std::shared_ptr&lt;XDriveModel&gt;&amp; imodel, const std::shared_ptr&lt;Odometry&gt;&amp; iodometry, std::unique_ptr&lt;IterativePosPIDController&gt; idistanceController, std::unique_ptr&lt;IterativePosPIDController&gt; iturnController, std::unique_ptr&lt;IterativePosPIDController&gt; iangleController, const TimeUtil&amp; itimeUtil); virtual ~OdomXController() = default; /** * Strafe a distance in a relative direction while correcting angle using an AngleCalculator * * @param distance The distance * @param direction The relative direction of the strafing * @param angleCalculator The angle calculator * @param turnScale The turn scale * @param settler The settler */ virtual void strafeRelativeDirection(const QLength&amp; distance, const QAngle&amp; direction, const AngleCalculator&amp; angleCalculator = makeAngleCalculator(), double turnScale = 1, const Settler&amp; settler = defaultDriveAngleSettler); /** * Strafe a distance in an absolute direction while correcting angle using an AngleCalculator * * @param distance The distance * @param direction The absolute direction of the strafing * @param angleCalculator The angle calculator * @param turnScale The turn scale * @param settler The settler */ virtual void strafeAbsoluteDirection(const QLength&amp; distance, const QAngle&amp; direction, const AngleCalculator&amp; angleCalculator = makeAngleCalculator(), double turnScale = 1, const Settler&amp; settler = defaultDriveAngleSettler); /** * Strafe to a point using field-centric math and an AngleCalculator * * @param targetPoint The target point * @param angleCalculator The angle calculator * @param turnScale The turn scale * @param settler The settler */ virtual void strafeToPoint(const Vector&amp; targetPoint, const AngleCalculator&amp; angleCalculator = makeAngleCalculator(), double turnScale = 1, const Settler&amp; settler = defaultDriveAngleSettler); protected: std::shared_ptr&lt;XDriveModel&gt; xModel {nullptr}; }; .",
    "url": "https://theol0403.github.io/7842B-Journal/2019-11-20/odom-x-controller/",
    "relUrl": "/2019-11-20/odom-x-controller/"
  }
  ,"12": {
    "title": "Odom Controller",
    "content": "In order to move to specific coordinates, I needed to design a versatile controller to allow me to tell the robot to drive to a point, using odometry information. This is quite a complex task, as it involves moving the robot in two dimensions while being efficient. . Basic Movement . Once you know the position of the robot and where you want to move, the challenge is to actually move there. Here is a very simple algorithm to drive to a point: . Calculate angle to target | Turn to face the target | Calculate distance to target | Move distance to reach target | While this algorithm works decently well, it is quite slow and is not able to dynamically adjust while on-course. I instead wanted to make an algorithm that would curve toward the target, and calculate course adjustments on the fly. . PID to Heading and Distance . The first algorithm I tried was PID. The distance and angle to the target would be sent to 2 PID controllers, and then the outputs would be combined. There were two problems with this method. . The first was that the algorithm had to be terminated when the robot reached the general vicinity of the target, or else the robot would start having a spasm. This is because the PID needs to have a negative input signal to be able to back up and settle. . However, when calculating distance to a point (using Pythagoras), you can’t know when you overshoot the target. Therefore, the robot could only move forward, so when it reaches and overshoots the target, the angle to the target flips 180 degrees and the distance PID goes full throttle. . The second problem with this method is that it is not the most efficient. If the robot was perpendicular to the target, the distance PID would output full power, even though moving forward is the wrong thing to do. . . Instead, I wanted an algorithm that prioritized turning over moving, and that only moves when doing so would make the robot get nearer to the target. . Adaptive PID Seeking . I posed this question: “If the robot is locked to its current heading, so it can only move forward/backward, how can it move in a straight line to get closest to the point as possible?”. . If the robot was perpendicular to the target, the answer would be 0. But as the robot rotates to face the target, the answer becomes more and more. Here are some images illustrating the question (the answer is the length of the red line): . . After some research and help, I was able to implement the math for this. When doing distance PID on the output of these calculations, the robot was able to move much more efficiently. I also had to implement some logic to be able to drive backward. . The reason this algorithm works great for settling is that if I turn off the angle PID when the robot is a certain distance away from the target, the adaptive distance PID brings the robot to a settled stop, giving a negative signal to back up. . To test this algorithm, I made a javascript simulation. You can see how the robot prefers turning over driving, and how it settles smoothly: . ![](images/479e47a7761f01d48f5c41f49bfbaeaf4f75f1c8.gif) Settling . Every single autonomous motion has a settling period. However, I wanted the settling to be customizable for every single command. I wanted to be able to settle a few different ways: . All PID controllers come to a rest | All PID controllers get to some margin of error | The robot gets to a certain requirement, such as a certain distance from a point or a certain angle | . To do this, I created a parameter in each movement function that accepts a special kind of function called a Settler. Every loop, the movement function will ask the settler “am I settled yet?” and then the function will return true when it’s conditions are met. . Here is the lib7842 implementation of a Settler: . /** * Function that returns true to end chassis movement. Used to implement different settling methods. */ using Settler = std::function&lt;bool(const OdomController&amp; odom)&gt;; . Then, I created a few default settling functions and added the functionality to generate new settling functions on the fly. For example, here is a command with a settler that waits for all the PID controllers to settle. . driveToPoint({1_ft, 1_ft}, 1, driveSettle); . If I wanted to make the robot exit the movement when it was 4 inches away from the target, I could use a distance-based settler. . driveToPoint({1_ft, 1_ft}, 1, makeSettle(4_in)); . Here are some examples of settler creators: . /** * Make a Settler that exits when angle error is within given range * @param angle The angle error threshold */ static Settler makeSettler(const QAngle&amp; angle); /** * Make a Settler that exits when distance error is within given range * @param distance The distance error threshold */ static Settler makeSettler(const QLength&amp; distance); . Turning . All turning is essentially the same motion. The only difference with all possible turns is the goal calculation and movement method (point, pivot, or arc). I wanted to write only one turning algorithm, and have all the implementations plug-in. . Thus I used the same modular function pattern as the settling system and added parameters in the turning function to fulfill the angle calculation and movement method. Here are a few examples of a turn command: . turn(makeAngle({1_ft, 1_ft}), pointTurn, turnSettle); turn(makeAngle(90_deg), leftPivot, makeSettle(5_deg)); . Here is the lib7842 implementation of Turner and AngleCalculator: . /** * Function that accepts a turning velocity and controls execution to the chassis. Used to implement * a point or pivot turn. */ using Turner = std::function&lt;void(ChassisModel&amp; model, double vel)&gt;; /** * Function that returns an angle for the chassis to seek. Examples can be an AngleCalculator that * returns the angle to a point, or an angle to an absolute angle. */ using AngleCalculator = std::function&lt;QAngle(const OdomController&amp; odom)&gt;; . Here is the basis turn function that all other turns use: . /** * Turn the chassis using the given AngleCalculator * * @param angleCalculator The angle calculator * @param turner The turner * @param settler The settler */ virtual void turn(const AngleCalculator&amp; angleCalculator, const Turner&amp; turner = pointTurn, const Settler&amp; settler = defaultTurnSettler); . Here are a few AngleCalculator creators: . /** * Make an AngleCalculator that seeks a given absolute angle * * @param angle The angle */ static AngleCalculator makeAngleCalculator(const QAngle&amp; angle); /** * Make an AngleCaclulator that seeks a given point. * * @param point The point */ static AngleCalculator makeAngleCalculator(const Vector&amp; point); . These AngleCalculators will provide the foundation on which to build X-Drive control on. . I also made a few helper functions to provide more expressive turning commands: turnToAngle(angle), turnAngle(angle), and turnToPoint(point), which all just call turn(angleCalc) internally. . OdomController Code: . Here is the entire OdomController header: . /** * Function that returns true to end chassis movement. Used to implement different settling methods. */ using Settler = std::function&lt;bool(const OdomController&amp; odom)&gt;; /** * Function that accepts a turning velocity and controls execution to the chassis. Used to implement * a point or pivot turn. */ using Turner = std::function&lt;void(ChassisModel&amp; model, double vel)&gt;; /** * Function that returns an angle for the chassis to seek. Examples can be an AngleCalculator that * returns the angle to a point, or an angle to an absolute angle. */ using AngleCalculator = std::function&lt;QAngle(const OdomController&amp; odom)&gt;; /** * Odometry motion controller for skid-steer chassis. */ class OdomController { public: /** * OdomController. Implements chassis movement algorithms * * @param imodel The chassis model * @param iodometry The chassis odometry * @param idistanceController The distance pid controller * @param iturnController The turning pid controller * @param iangleController The angle pid controller, used to keep distance driving straight * @param isettleRadius The radius from the target point to give up angle correction * @param itimeUtil The time utility */ OdomController(const std::shared_ptr&lt;ChassisModel&gt;&amp; imodel, const std::shared_ptr&lt;Odometry&gt;&amp; iodometry, std::unique_ptr&lt;IterativePosPIDController&gt; idistanceController, std::unique_ptr&lt;IterativePosPIDController&gt; iturnController, std::unique_ptr&lt;IterativePosPIDController&gt; iangleController, const QLength&amp; isettleRadius, const TimeUtil&amp; itimeUtil); virtual ~OdomController() = default; /** * Turn the chassis using the given AngleCalculator * * @param angleCalculator The angle calculator * @param turner The turner * @param settler The settler */ virtual void turn(const AngleCalculator&amp; angleCalculator, const Turner&amp; turner = pointTurn, const Settler&amp; settler = defaultTurnSettler); /** * Turn the chassis to face an absolute angle * * @param angle The angle * @param turner The turner * @param settler The settler */ virtual void turnToAngle(const QAngle&amp; angle, const Turner&amp; turner = pointTurn, const Settler&amp; settler = defaultTurnSettler); /** * Turn the chassis to face a relative angle * * @param angle The angle * @param turner The turner * @param settler The settler */ virtual void turnAngle(const QAngle&amp; angle, const Turner&amp; turner = pointTurn, const Settler&amp; settler = defaultTurnSettler); /** * Turn the chassis to face a point * * @param point The point * @param turner The turner * @param settler The settler */ virtual void turnToPoint(const Vector&amp; point, const Turner&amp; turner = pointTurn, const Settler&amp; settler = defaultTurnSettler); /** * Drive a distance while correcting angle using an AngleCalculator * * @param distance The distance * @param angleCalculator The angle calculator * @param turnScale The turn scale * @param settler The settler */ virtual void moveDistanceAtAngle(const QLength&amp; distance, const AngleCalculator&amp; angleCalculator, double turnScale, const Settler&amp; settler = defaultDriveAngleSettler); /** * Drive a distance while maintaining starting angle * * @param distance The distance * @param settler The settler */ virtual void moveDistance(const QLength&amp; distance, const Settler&amp; settler = defaultDriveAngleSettler); /** * Drive to a point using custom point seeking * * @param targetPoint The target point * @param turnScale The turn scale used to control the priority of turning over driving. A * higher value will make the robot turn to face the point sooner * @param settler The settler */ virtual void driveToPoint(const Vector&amp; targetPoint, double turnScale = 1, const Settler&amp; settler = defaultDriveAngleSettler); /** * Drive to a point using simple point seeking * * @param targetPoint The target point * @param turnScale The turn scale used to control the priority of turning over driving. A * higher value will make the robot turn to face the point sooner * @param settler The settler */ virtual void driveToPoint2(const Vector&amp; targetPoint, double turnScale = 1, const Settler&amp; settler = defaultDriveAngleSettler); /** * A Settler that is used for turning which uses the turning pid&#39;s isSettled() method */ static bool defaultTurnSettler(const OdomController&amp; odom); /** * A Settler that is used for driving which uses the distance pid&#39;s isSettled() method */ static bool defaultDriveSettler(const OdomController&amp; odom); /** * A Settler that is used for driving which uses the distance and angle pid&#39;s isSettled() method */ static bool defaultDriveAngleSettler(const OdomController&amp; odom); /** * A Turner that executes a point turn which turns in place. Used as default for turn functions */ static void pointTurn(ChassisModel&amp; model, double vel); /** * A Turner that executes a left pivot, meaning it only moves the left motors. */ static void leftPivot(ChassisModel&amp; model, double vel); /** * A Turner that executes a right pivot, meaning it only moves the right motors. */ static void rightPivot(ChassisModel&amp; model, double vel); /** * Make a Settler that exits when angle error is within given range * @param angle The angle error threshold */ static Settler makeSettler(const QAngle&amp; angle); /** * Make a Settler that exits when distance error is within given range * @param distance The distance error threshold */ static Settler makeSettler(const QLength&amp; distance); /** * Make a Settler that exits when both angle and distance error is within given range. * @param angle The angle error threshold * @param distance The distance error threshold */ static Settler makeSettler(const QLength&amp; distance, const QAngle&amp; angle); /** * Make an AngleCalculator that seeks a given absolute angle * * @param angle The angle */ static AngleCalculator makeAngleCalculator(const QAngle&amp; angle); /** * Make an AngleCaclulator that seeks a given point. * * @param point The point */ static AngleCalculator makeAngleCalculator(const Vector&amp; point); /** * Make an AngleCaclulator that returns a constant error. The default settler needs to be changed * for a command using this calculator to settle. * * @param error The error * @return The angle calculator. */ static AngleCalculator makeAngleCalculator(double error); /** * Make an AngleCalculator that does nothing */ static AngleCalculator makeAngleCalculator(); /** * Get the odometry state. */ State getState() const; /** * Calculate distance from the chassis to the point */ QLength distanceToPoint(const Vector&amp; point) const; /** * Calculate angle from the chassis to the point */ QAngle angleToPoint(const Vector&amp; point) const; protected: /** * Reset the pid controllers, used before every motion */ virtual void resetPid(); std::shared_ptr&lt;ChassisModel&gt; model {nullptr}; std::shared_ptr&lt;Odometry&gt; odometry {nullptr}; std::unique_ptr&lt;IterativePosPIDController&gt; distanceController {nullptr}; std::unique_ptr&lt;IterativePosPIDController&gt; angleController {nullptr}; std::unique_ptr&lt;IterativePosPIDController&gt; turnController {nullptr}; const QLength settleRadius; TimeUtil timeUtil; QAngle angleErr = 0_deg; QLength distanceErr = 0_in; }; . Here is the motion algorithm to drive to a point using the adaptive seeking method: . void OdomController::driveToPoint(const Vector&amp; targetPoint, double turnScale, const Settler&amp; settler) { resetPid(); auto rate = timeUtil.getRate(); do { State state = getState(); Vector closestPoint = closest(state, targetPoint); QAngle angleToClose = state.angleTo(closestPoint); QAngle angleToTarget = state.angleTo(targetPoint); QLength distanceToClose = state.distTo(closestPoint); QLength distanceToTarget = state.distTo(targetPoint); // go backwards if (angleToClose.abs() &gt;= 90_deg) distanceToClose = -distanceToClose; if (distanceToTarget.abs() &lt; settleRadius) { angleErr = 0_deg; // used for settling distanceErr = distanceToClose; } else { angleErr = angleToTarget; // used for settling distanceErr = distanceToTarget; } // rotate angle to be +- 90 angleErr = rotateAngle90(angleErr); double angleVel = angleController-&gt;step(-angleErr.convert(degree)); double distanceVel = distanceController-&gt;step(-distanceToClose.convert(millimeter)); driveVector(model, distanceVel, angleVel * turnScale); rate-&gt;delayUntil(10_ms); } while (!settler(*this)); driveVector(model, 0, 0); } .",
    "url": "https://theol0403.github.io/7842B-Journal/2019-11-15/odom-controller/",
    "relUrl": "/2019-11-15/odom-controller/"
  }
  ,"13": {
    "title": "Unit Tests",
    "content": "lib7842 is a library that will be released to many teams around the world. In order to make it as bug-free and reliable as possible, all classes have tests written for them. These tests check to make sure all the code is working as expected, and that there are no crashes or bugs. . Tests are run by Azure Pipelines CI. Every commit I make on GitHub gets processed and tested in the cloud, with the results reported back to me. The automated process also runs static analysis via CppCheck, which can find bugs in my code. Finally I run valgrind and callgrind, a memory leak and profiler tool. . . Tests . I use a testing framework called doctest. It allows me to write expressive tests through the TDD (Test Driven Development) workflow. . Here is an example test: . GIVEN(&quot;a data point with some data&quot;) { DataPoint point1 {5_in, 3_in}; point1.setData(&quot;curvature&quot;, 5.0); point1.setData(&quot;distance&quot;, 5_m); point1.setData(&quot;velocity&quot;, 5_mps); point1.setData(&quot;segmentIndex&quot;, 5); THEN(&quot;constructors should work&quot;) { DataPath(); DataPath({point1}); DataPath({point1, point1}); DataPath(std::vector&lt;DataPoint&gt;({point1, point1})); } GIVEN(&quot;a path containing three points&quot;) { DataPath path({point1, point1, point1}); THEN(&quot;the size of the path should be three&quot;) { REQUIRE(path().size() == 3); } THEN(&quot;each point should contain data&quot;) { for (auto&amp;&amp; point : path()) { CHECK(point-&gt;getData&lt;double&gt;(&quot;curvature&quot;) == 5.0); CHECK(point-&gt;getData&lt;QLength&gt;(&quot;distance&quot;) == 5_m); CHECK(point-&gt;getData&lt;QSpeed&gt;(&quot;velocity&quot;) == 5_mps); CHECK(point-&gt;getData&lt;int&gt;(&quot;segmentIndex&quot;) == 5); } } GIVEN(&quot;a simple path generated from the data path&quot;) { SimplePath ipath = path.generate(); THEN(&quot;the size of the path should be three&quot;) { REQUIRE(ipath().size() == 3); } THEN(&quot;the positions should be the same&quot;) { for (auto&amp;&amp; point : ipath()) { CHECK(*point == point1); } } } } } . If any of the tests fail, I will be notified and I will be able to solve the problem. Tests have already found many bugs I would have missed, and is a great way to test code without needing a robot. . .",
    "url": "https://theol0403.github.io/7842B-Journal/2019-11-10/tests/",
    "relUrl": "/2019-11-10/tests/"
  }
  ,"14": {
    "title": "GUI",
    "content": "A large part of lib7842 is the GUI. It uses a third-party graphics library named LVGL for the elements. The GUI is fully tested and developed on my computer using a simulator, so that I don’t need to have a V5 brain handy. . Here is a screenshot of the GUI: . .",
    "url": "https://theol0403.github.io/7842B-Journal/2019-10-19/gui/",
    "relUrl": "/2019-10-19/gui/"
  }
  ,"15": {
    "title": "Task Wrapper",
    "content": "If a class requires a task as a member, it causes some problems. A pros::Task requires a callback function to run, but due to some limitations in c++, the address of that function needs to be known in compile-time. This means that the task callback needs to be static , which means that it does not belong to the class instance and it can’t access class members. To fix this, a pattern named trampoline is used. Trampoline is the act of passing a opaque pointer to the class object through the task to be received by the static function, having the static function cast the pointer to the correct class type, and calling a member function to execute the task. . Since implementing a trampoline requires a solid amount of boilerplate, I have written an abstract task wrapper that does this for me. To be able to run using unit tests and CI, I am using OkapiLib’s CrossPlatformTask as the task object. . Note how the this pointer is passed when task is constructed: . task = std::make_unique&lt;CrossplatformThread&gt;(trampoline, this, iname.c_str()); . Then, the pointer is cast by the trampoline and a virtual member loop() is called, which is then resolved by dynamic binding: . void TaskWrapper::trampoline(void* iparam) { pros::delay(20); static_cast&lt;TaskWrapper*&gt;(iparam)-&gt;loop(); } . Here is the full TaskWrapper implementation: . /** * A utility class that wraps a task trampoline. To use, simply inherit your class from TaskWrapper * and override the `loop` method. To start the task, the `startTask` method must be called, either * from the constructor or from outside the class. */ class TaskWrapper { protected: explicit TaskWrapper(const std::shared_ptr&lt;Logger&gt;&amp; ilogger = Logger::getDefaultLogger()); TaskWrapper(const TaskWrapper&amp; itask) = delete; TaskWrapper(TaskWrapper&amp;&amp; itask) = default; virtual ~TaskWrapper() = default; /** * Override this function to implement a custom task loop. * Will throw if not overridden. */ virtual void loop(); public: /** * Start the task. * * @param iname The task name, optional. */ virtual void startTask(const std::string&amp; iname = &quot;TaskWrapper&quot;); /** * Kill the task. */ virtual void killTask(); /** * Get the task name. * * @return The name. */ virtual std::string getName(); protected: std::shared_ptr&lt;Logger&gt; logger {nullptr}; private: static void trampoline(void* iparam); std::unique_ptr&lt;CrossplatformThread&gt; task {nullptr}; }; . Source file: . TaskWrapper::TaskWrapper(const std::shared_ptr&lt;Logger&gt;&amp; ilogger) : logger(ilogger) {} void TaskWrapper::loop() { std::string msg(&quot;TaskWrapper::loop: loop is not overridden&quot;); LOG_ERROR(msg); throw std::runtime_error(msg); } void TaskWrapper::startTask(const std::string&amp; iname) { if (task) LOG_INFO(&quot;TaskWrapper::startTask: restarting task: &quot; + iname); task = std::make_unique&lt;CrossplatformThread&gt;(trampoline, this, iname.c_str()); } void TaskWrapper::killTask() { task = nullptr; } std::string TaskWrapper::getName() { return task-&gt;getName(); }; void TaskWrapper::trampoline(void* iparam) { pros::delay(20); static_cast&lt;TaskWrapper*&gt;(iparam)-&gt;loop(); } .",
    "url": "https://theol0403.github.io/7842B-Journal/2019-10-18/task-wrapper/",
    "relUrl": "/2019-10-18/task-wrapper/"
  }
  ,"16": {
    "title": "State Machine",
    "content": "A statemachine is an elegant way of programming a subsystem, and makes it easy to control both in driver control and autonomous. A statemachine is usually implemented using an enum containing a list of states, and then a switch statement in a separate thread that implements each state. . However, implementing a statemachine requires a substantial amount of redundant code to set up the task with setter and getter functions. This is why I wrote an abstract StateMachine wrapper that reduces said boilerplate. StateMachine inherits task functionality from Task Wrapper. . Here is the class, which accepts the enum type as a template parameter: . /** * State machine helper class. * * @tparam States An enum class representing the states of a subsystem. Required to have an * off state. * @tparam assumedState Optional - The assumed last state when using setNewState. Initially calling * setNewState with this state will not trigger a state transition. */ template &lt;typename States, States assumedState = States::off&gt; class StateMachine : public TaskWrapper { public: StateMachine() = default; virtual ~StateMachine() = default; /** * Sets the state. * * @param istate The state */ virtual void setState(const States&amp; istate) { state = istate; } /** * Sets the state and waits until the statemachine reports done. * * @param istate The istate */ virtual void setStateBlocking(const States&amp; istate) { _isDone = false; state = istate; while (!isDone()) { pros::delay(20); }; } /** * Sets the state only if the state is different from the last time this function was called. * * @param istate The state */ virtual void setNewState(const States&amp; istate) { if (istate != lastState) { state = istate; lastState = istate; } } /** * Gets the state. * * @return The state. */ virtual const States&amp; getState() const { return state; } /** * Gets the state. * * @return The state. */ virtual bool isDone() const { return _isDone; } protected: /** * Override this method to implement setup procedures. */ virtual void initialize() = 0; /** * Override this method to implement the statemachine task */ void loop() override = 0; virtual void setDone() { _isDone = true; } States state {States::off}; States lastState {assumedState}; bool _isDone = false; }; .",
    "url": "https://theol0403.github.io/7842B-Journal/2019-10-16/statemachine/",
    "relUrl": "/2019-10-16/statemachine/"
  }
  ,"17": {
    "title": "Motion Algorithms",
    "content": "A big focus for this year has been motion algorithms for autonomous. Motion algorithms allow for a faster, easier, and more competitive autonomous, and are really fun to make. . This year, we have built an X-Drive robot, which opens up a wide range of possibilities for control. Having a holonomic chassis means that we can have heading-agnostic movement functions, meaning that we can drive any direction while facing any angle. This opens up possibilities for turning while driving, and also makes driving to points much easier as the heading of the robot is independent from movement. . Odometry . To be able to execute complex movements that are not straight lines, we need to have a way to track the robot’s position. This both improves accuracy and makes writing algorithms much easier as we can always know the absolute position and angle of the robot in the field. . To do this, we used an odometry algorithm provided by team 5225A. With the use of three freely-spinning tracking wheels, we are able to use trigonometry to calculate the absolute position of the robot in the field. . . A very useful trick we have learned is to calculate the robot’s absolute heading, we can use the following formula: . angleRadians = (leftInch - rightInch) / chassisWidthInch . Motion . Motion algorithms will be a work in progress throughout the year. I will be implementing them in lib7842, so I aim to have good programming practice when making them. I will be starting from last year’s code which will make things easier. . Knowing where the robot is at all times opens up many options. For example, here are some commands we can use to build autonomous programs: . turnToAngle(angle); turnToPoint(point); driveDistance(distance); driveToPoint(point); followPath(path); . Since we have an X-Drive robot, we can often combine driving and turning into a single action, so the turning functions are barely used. . Planning . Since we use odometry and motion algorithms to tell the robot to go to certain coordinates, we can much more easily plan autonomous programs using a map. We overlaid a coordinate system over a top-down view of the field, so we can simply plot and record points: . .",
    "url": "https://theol0403.github.io/7842B-Journal/2019-10-15/motion-algorithms/",
    "relUrl": "/2019-10-15/motion-algorithms/"
  }
  ,"18": {
    "title": "Claw Control",
    "content": "Today I had to figure out claw mapping and control. Our claw has an individual motor for each side of the claw, so I decided to keep the two sides completely separate. I wrote a statemachine that is used for both sides of the claw. When the driver releases buttons that either open or close the claw, it brakes the claw to prevent it from coasting. . enum class clawStates { off, close, open, clamp, release, brake }; class Claw : public StateMachine&lt;clawStates&gt; { // ... }; . Here are the states: . case clawStates::off: claw-&gt;moveVoltage(0); break; case clawStates::close: claw-&gt;moveVoltage(12000); break; case clawStates::open: claw-&gt;moveVoltage(-12000); break; case clawStates::clamp: pid-&gt;setTarget(50); claw-&gt;moveVoltage(pid-&gt;step(claw-&gt;getPosition()) * 12000); break; case clawStates::release: pid-&gt;setTarget(-200); claw-&gt;moveVoltage(pid-&gt;step(claw-&gt;getPosition()) * 12000); break; case clawStates::brake: claw-&gt;moveVelocity(0); break; . Finally, here is the driver control layout for a single claw: . if (mDigital(L2) &amp;&amp; mDigital(L1)) { leftClawState = clawStates::off; } else if (mDigital(L2)) { leftClawState = clawStates::clamp; } else if (mDigital(L1)) { leftClawState = clawStates::release; } else { leftClawState = clawStates::brake; } if (leftClawState != lastLeftClawState) { Robot::clawLeft()-&gt;setState(leftClawState); lastLeftClawState = leftClawState; } .",
    "url": "https://theol0403.github.io/7842B-Journal/2019-10-11/claw-control/",
    "relUrl": "/2019-10-11/claw-control/"
  }
  ,"19": {
    "title": "Lift PID",
    "content": "Today I worked on the lift PID. I had to find a way to stabilize the sides. . Currently, here is the driver control mapping: . bool moveSlow = mDigital(R1); if (mDigital(L2) &amp;&amp; mDigital(L1)) { liftState = liftStates::bottom; } else if (mDigital(L1)) { liftState = moveSlow ? liftStates::upSlow : liftStates::up; } else if (mDigital(L2)) { liftState = moveSlow ? liftStates::downSlow : liftStates::down; } else { liftState = liftStates::hold; } . When the driver presses L2 or L1, the lift moves at full speed, and when the driver lets go, the lift tries to maintain the position where the button was let go. However, since there is an individual PID running on each side of the lift, it might try to maintain the lift to not be straight. To fix this problem, I averaged the two sides of the lift and used that for my PID target. . Do do this, I used std::valarray , which makes it easier to do math with a set of numbers: . std::valarray&lt;double&gt; Lift::getPosition() const { return std::valarray&lt;double&gt;({lift[0]-&gt;getPosition(), lift[1]-&gt;getPosition()}) - startPos; } // calculate hold position by averaging holdPos = getPosition().sum() / 2.0; . Code summary . Here are the statemachine states in question: . case liftStates::off: lift[0]-&gt;moveVoltage(0); lift[1]-&gt;moveVoltage(0); break; case liftStates::up: lift[0]-&gt;moveVoltage(12000); lift[1]-&gt;moveVoltage(12000); break; case liftStates::down: lift[0]-&gt;moveVoltage(-12000); lift[1]-&gt;moveVoltage(-12000); break; case liftStates::upSlow: lift[0]-&gt;moveVelocity(50); lift[1]-&gt;moveVelocity(50); break; case liftStates::downSlow: lift[0]-&gt;moveVelocity(-50); lift[1]-&gt;moveVelocity(-50); break; case liftStates::hold: holdPos = getPosition().sum() / 2.0; state = liftStates::holdAtPos; break; case liftStates::holdAtPos: pid[0]-&gt;setTarget(holdPos[0]); pid[1]-&gt;setTarget(holdPos[1]); lift[0]-&gt;moveVoltage(pid[0]-&gt;step(getPosition()[0]) * 12000); lift[1]-&gt;moveVoltage(pid[1]-&gt;step(getPosition()[1]) * 12000); break; case liftStates::bottom: pid[0]-&gt;setTarget(0); pid[1]-&gt;setTarget(0); lift[0]-&gt;moveVoltage(pid[0]-&gt;step(getPosition()[0]) * 12000); lift[1]-&gt;moveVoltage(pid[1]-&gt;step(getPosition()[1]) * 12000); break; .",
    "url": "https://theol0403.github.io/7842B-Journal/2019-10-10/lift-pid/",
    "relUrl": "/2019-10-10/lift-pid/"
  }
  ,"20": {
    "title": "2018-19 Showcase",
    "content": "Hello everyone! . I’m Theo from 7842F, and I’m the programmer for our team. . I’ve been meaning to make this post ever since worlds, but I haven’t had the time to do so. I now finally have some time before my school starts (I still have 1 week of summer) to show the VEX community our robot and all the different designs we have implemented to make it. . Even though the Turning Point season is way over, the things I will show in this post still applies to this year and VEX in general. . Who Are We? . 7842F is a 2-person team from Vancouver Island, Canada. We meet to build twice a week for ~4 hours, and we design and program at home. We are not allowed to take our robots home, so we try to be as organized and efficient as possible with the time we have to build. Our team captain is Jacob Walter, and he did pretty much all the designing, cadding, building, documentation, journals, and driving. I did all the programming, helped with building, made our website, and was a partner driver at worlds. . Video Explanation/Demo . I recorded a brief video a while ago demonstrating our robot. The following post will cover in more detail the designs that went into each system. . https://www.youtube.com/watch?v=iW4RlnHbDrY . Flywheel Velocity Control . Throughout the TP season, we stuck with a flywheel design. We improved and upgraded it through the year, and gained a lot of knowledge about using it. We went through 3 different flywheel designs. The first was a 1m back-loading simple flywheel, the second a 2m front-loading indexed flywheel, and the last a 2m front loading angling flywheel. . In all our designs, we needed to be able to control the flywheel speed as precisely and consistently as possible. It was also crucial that the flywheel was able to regain its speed as fast as possible after a ball was shot. Since we were using the Cortex system during the development of our flywheel control system, we were able to take advantage of RobotC’s amazing debugger system and graph our flywheel performance. . . Traditional Control . First of all, we tried “traditional” velocity pid control. This is usually what is taught in control theory, and is implemented as output += pid(...);. This means that the motor power being sent to the flywheel is being tweaked incrementally each step by a PID controller. . The issue with this method is that a flywheel is very unresponsive, so the PID would ramp up the motor power much too high, and then the flywheel would overshoot, and then the PID would take a long time to get the flywheel to reach the goal. If we tried to lower the PID gains, the flywheel would be too sluggish and take much too long to react. . This is the velocity PID algorithm used in V5 Motors, OkapiLib, and most velocity PID controllers. . Custom Algorithm - Feedforward . I decided to scrap that algorithm and try to make my own. First, I wanted something that given a target RPM would know right away the general voltage that needed to be sent to the motor. . I did this by introducing a new term named feedforward. Feedforward is simply target * kF, in other words, the higher the target velocity, the proportionally higher the output power. When kF is tuned right, it can bring the flywheel to the approximate ballpark velocity, assuming linear flywheel velocity to input voltage. . For example, if the target is 2800rpm, and kF is tuned for our early-season flywheel, it would output 90 power. This is the term that does most of the grunt work involved with moving the flywheel. . Using feedforward, I could then implement my PID as output = pidf(...); . Accuracy . However, feedforward can’t do all the work. The velocity might not be linear to output power, or there may be some friction or other interference. This is where P (Proportional) comes in. P, supported by F, does the rest of the work by nudging the flywheel power in the right direction to completely reach the goal. For this to work, P must be very high, leading to another problem: oscillation. . The signal coming in from flywheel velocity calculations are quite noisy if you want them to be up-to-date. When the algorithm sees this noise, and kP is high, this translates to noise in the output signal. This means the motor starts oscillating, which translates to real flywheel oscillation. This translates into an even more noisy signal going into the PID, causing a vicious cycle of oscillation. . . Signal EMA Filtering . To solve this issue, the input signal needs to be smoothed. For this, I use an EMA (Exponential Moving Average) filter. . https://en.wikipedia.org/wiki/Moving_average . EMA takes the flywheel reading over time and strikes a balance between taking into account the new reading and keeping the old one. If you overuse EMA, it will cause the signal to be unresponsive and outdated, causing more oscillation, so it is important to use just the right amount to smooth noise. . . Now that EMA causes the input signal to be smooth, the output power will also be steady. This is exactly what we want when controlling a flywheel: smooth, steady power. Now that the input noise and oscillations are damped and filtered out, I can use a large kP gain to be as precise as possible without fearing oscillation. . Note: I could also try to use the I term for more accuracy, but I have not had a good experience with it, as it likes to introduce a lot of oscillations into the system. In my algorithm, I have not implemented I. . Derivative EMA Filtering . When the flywheel shoots a ball, I want the flywheel to recover as quickly as possible, so that the next shot will be consistent. That means I want the motors to spike to full power while the ball is being shot, not once the flywheel has slowed down enough for P to kick in. To do this, I use the D (Derivative) term. D is simply the rate of change of the error, applied to the motors to try to fight against that rate of change. . I don’t just want the D to kick in while the flywheel is slowing down, I also want it to linger a bit after the shot to provide an extra boost. To do this, I also apply an EMA filter on the D. Filtering D is common practice, as it makes D have time to affect the output instead of being there for only a few timeslices. Without filtering, it only acts against the change of motion exactly when it detects it, so in the case of a flywheel, when you shoot a ball, the only effect D will have is exactly when the flywheel is slowing down. With filtering, D lingers a bit after the initial high rate of change. . . As you can see, using a filtered D allows the flywheel to resume target speed as fast as possible. . Slew Rate . Finally, to protect the motors, I apply a one-way slew rate to the output power. This protects the motors during ramp-up and dampens the system. The flywheel power can drop very fast, but it needs to gradually climb back up. . If you look at most of the above graphs, you can see that the initial acceleration of the motor power is gradual. In the following graph, look at how the motor power (green) is limited and ramps up slowly even though the PID would have it at full power instantly. . . Slew rate can be implemented with a simple algorithm. Here is the pseudocode: . increment = output - outputLast; if(abs(increment) &gt; slewLimit) output = outputLast + slewLimit * sgn(increment); outputLast = output; . Flywheel Tuning . To properly tune the flywheel constants, I needed a solution that did not involve redownloading the code every iteration. With RobotC, I could directly tune the constants using the debugger, but with PROS V5, there is no such tool. This is why I designed an LVGL tuning utility. . V1: https://youtu.be/SaY6B3MW3AI . V2: . . I also made a graphing utility to visualize the flywheel performance: . . . V5 Flywheel Datalogging . As you may know, the programming solutions V5 do not have any of the remote debugging features of RobotC. While I did have the GUI graph, I wanted a solution that could record in the background and report to the computer. . Thus I wrote a utility that saved a log of all the flywheel information in a CSV on the SD card. Each time the code ran, it would save a log of the flywheel state. I could then read these files on my computer and import them into graphing software such as R, Excel, or mathplotlib. . I kept this logger running in competitions and even worlds, so if something happened to the flywheel we could go back and look at its log, which contained information like temperature. I recommend using the SD card to store information, as it can be a useful tool. You can also use a third-party library to do the CSV writing and file management for you. . Flywheel Code . I have decided to release the code for this flywheel algorithm! . They are split into 3 parts: . EMA Filter | Velocity PID with D EMA | Implementation with signal EMA and Slew Rate | RobotC . The files are located in . /Libraries/7842FLib/Filter/emaFilter.c | /Libraries/7842FLib/PID/PIDEMASystem.c | /Shared/MainFlywheelTask.c: | https://github.com/theol0403/7842F-Alpha-Code-RobotC . PROS (V5) . https://gist.github.com/theol0403/0b484a5a00274edd5b85aa16009ba1ab . . Angling Hood . For our third robot, the one we took to worlds, we made an angling flywheel hood. It took us months to perfect, but it worked well in the end. . Double Ratcheting System . Our worlds robot had a 2m flywheel. However, we also wanted a 4m base, an intake, an indexer, and an arm. To achieve this, we had to use a motor sharing system. Since the flywheel motors only spin in one direction, we took advantage of the other direction by using a double ratchet system. We could then power another subsystem when the motors spun backward. With this system, we were able to use 2 motors to power our flywheel, indexer, and angler. . We needed smaller and more compact ratchets than was provided by VEX, so Jacob designed a custom ratchet and submitted it to the CAD online challenge: https://challenges.robotevents.com/challenge/94/entry/6325 . . He then expanded that system by making a compact double ratchet. . . The angler is ratcheted so it can only be moved forward. When the angler reaches the maximum position, a slip gear brings the angler back to the resting position. . Operation . Here is the flywheel system’s typical routine: . Both motors spin CCW and work together to spin up the flywheel | When a shooting angle is requested, the angler motor spins CW to engage and move the angler, cycling if needed. The indexer motor maintains the flywheel’s speed. | When the angler is at the desired position, the angler motor resumes powering the flywheel. | When it is time to shoot, the indexer motor spins CW, engaging the indexer and shooting the ball. The angler motor maintains the flywheel’s speed. | The indexer motor resumes powering the flywheel. | If a doubleshot is selected, the angle for the next flag is requested and steps 2-5 repeat | Both motors continue powering the flywheel until the next angle adjustment or shot | Here are a few clips showing the robot doing double shots: . https://youtu.be/l6ZdQ_tHcqg . Angle Request System . The thing that makes our angler different compared to other angling hoods is that we can specify the exact angle we want the ball to shoot. To make the most of this ability, we needed to record the perfect shooting angle for each flag (top and middle) given various shooting positions. . We decided to have 4 shooting positions: . Position 1 is when the angler is all the way back and shoots the top flag | Position 2 is with the back of the robot against the platform | Position 3 is with the front of the robot against the platform | Position 4 is with the back of the robot against the back of the court | If we were on the near starting tile, we could also turn and shoot across the court using angler position 3 and 4. . . Having these positions tuned allowed us to do some pretty cool shots: . . Driver Interface/Controller Mapping . Having all these different shooting configurations required having a dedicated driver setting them. Thus I became the partner driver and controlled the angler. . Our workflow was this: the main driver (Jacob) would grab balls, and then head for any of our 4 shooting positions. He would tell me ahead of time which position he was planning to shoot at. . I would then press the buttons corresponding to that position, so the angler would be at the proper position ahead of time so it could be ready to shoot . After the driver lined up for the shot, I would press the shoot button, which would then execute whatever setting I had specified (top/middle/doubleshot at what position). . Here is our controller mapping: . . I also have a display on the controller that gives me some useful information: . . It tells me which distance and which flag is selected, whether the flywheel is at target velocity, the time left in the match, the robot’s battery, and the controller ID. This display was useful for driving at competitions. A copy of this screen is also on the master controller. . Angle Tuning . To tune the hood angles I experimented with various options. I tried using the controller buttons to tune the angles and writing logs to the SD or the terminal, and making a GUI. They all worked to some extent, but the controller was awkward so I stuck with the GUI option, as it was the most flexible and fast to use. . . The Dist buttons allowed me to control which distance setting to change the angles for, and the Top and Mid buttons allowed me to adjust the angles for that distance. The visualization in the middle of the GUI shows the hood angles - white is the hood’s current angle, and black and blue are the top and mid angles, respectively. . Code Implementation . The angler system was one of the most complicated programs I’ve ever made. It needed to be able to execute a series of dependent actions, but be asynchronous and interruptible. It also needed to be able to manage two other systems (flywheel and indexer) that were independently controlled, delegating motor ownership between them. It also needed to have a clean outside interface for drivercontrol and autonomous. . The solution involved making a statemachine that had a stack containing a list of pending actions. Each action would execute until its conditions were met, and then it would pop itself out of the stack. If an action needed another action to execute, then it would push that action onto the stack. . Here are all the possible actions the angler could take: . enum shootStates { off, //control to flywheel and intake standby, //back position, control to flywheel angling, //indefinite angling cycle, //head to back position extend, //move to extended position waitForSlip, //wait until hood slips waitForRetract, //wait until hood back to 0 pos angleTop, //drop hood to top angle angleMiddle, //drop hood to middle angle angleTopPlatform, //angle top from platform angleMiddlePlatform, //angle middle from platform angleOut, //drop hood to out (ground flag) angle angleTarget, //drop hood to target angle waitForDoubleShot, //if distance is large enough, wait before second shot waitForBall, //wait for ball to be in indexer waitForFlywheel, //wait until flywheel is ready enableShoot, //shoot indexer waitForShoot, //delays until shot detected reportDone, //lets autonomous know loopJob, //reloads current job loopMacro //reloads current macro }; . I then defined a collection of “macros”, groups of actions put together in a sequence: . enum class shootMacros { off, shootTop, shootMiddle, shootBoth, shootTopPlatform, shootMiddlePlatform, shootBothPlatform, shootOut, shootTarget, shoot, angle, cycle }; . Once I had these self-executing macros set up, I could tell the angler statemachine to “shootBoth”, and it would execute these actions: . angleTop | enableShoot | angleMiddle | waitForDoubleShot | enableShoot | reportDone | cycle | standBy | . It was a whole other challenge making the interface between the controller buttons and the statemachine macros, but I won’t get into that in this post. . Our angler system allowed us to shoot from practically anywhere in the court, and at worlds we took advantage of this - the large majority of our shots were taken from behind the platform. It took us a very long time and a lot of work to develop, but it worked very well in the end. . . Odometry/Autonomous . This past year we have developed odometry for our robot. Odometry is the act of tracking the robot’s position in the court and then using that information for autonomous routines. Instead of the standard “drive distance, turn angle”, I can use odometry to say “drive to coordinate, aim at coordinate”. The algorithm for the tracking was generously provided by 5225A, but I developed all the infrastructure and movement algorithms. . We used 2 free-spinning tracking wheels on our robot. Tracking wheels are designed to give the most precision to odometry as possible, as powered wheels can slip and are not as precise. We opted not to use a third tracking wheel because we did not have physical space to put it and we didn’t have any extra sensor ports. If possible I would recommend having a third wheel, as we had some consistency issues/drift because the tracking wheels would sometimes slide sideways. . . Odometry Debugging . Odometry is one of the most difficult things to diagnose if something goes wrong. You don’t know if the wheels failed, if the sensors failed, or if the code is wrong, and in what way. To help alleviate some of that pain, I wrote a GUI utility that helped us pinpoint problems. . . With this, you can try moving the robot in a straight line and see if one sensor is lagging behind the other, or to see if the tracking algorithm is broken. As a tool to help others (and as an incentive to help test OkapLib v4’s beta odometry system), I have published the code for this. . https://github.com/theol0403/odomDebug . Movement . Once you know the position of the robot and where you want to move, the challenge is to actually move there. Here is a basic algorithm to drive to a point: . Calculate angle to target | Turn to face the target | Calculate distance to target | Move distance to reach target | . While this algorithm works decently well, it is quite slow and is not able to dynamically adjust while on-course. I instead wanted to make an algorithm that would curve toward the target, and calculate course adjustments on the fly. . PID to heading and distance . The first algorithm that was tried was PID. The distance and angle to the target would be sent to 2 PID controllers, and then the outputs would be combined. There were two problems with this method. . The first was that the algorithm had to be terminated when the robot reached the general vicinity of the target, or else the robot would start having a spasm. Think about it - PID needs to have a negative input signal to be able to back up and settle. However, when calculating distance to a point (using pythagoras), you can’t know when you overshoot the target. Therefore, the robot can only move forward, so when it reaches and overshoots the target, the angle to the target flips 180 degrees and the distance PID goes full throttle. This causes the robot to go crazy. . The second problem with this method is that it is not the most efficient. If the robot was perpendicular to the target, the distance PID would output full power, even though moving forward is the wrong thing to do. . . Instead, I wanted an algorithm that prioritized turning over moving, and that only moves when doing so would make the robot get nearer to the target. . Adaptive PID Seeking . I posed this question: “If the robot is locked to its current heading, so it can only move forward/backward, how can it move in a straight line to get closest to the point as possible?”. . If the robot was perpendicular to the target, the answer would be 0. But as the robot rotates to face the target, the answer becomes more and more. Here are some images illustrating the question (the answer is the length of the red line): . . With the help of others, I was able to implement the math for this. When doing distance PID on the output of these calculations, the robot was able to move much more efficiently. I also had to implement some logic to be able to drive backward. The reason this algorithm works great for settling is that if I turn off the angle PID when the robot is a certain distance away from the target, the adaptive distance PID brings the robot to a settled stop, giving a negative signal to back up. . To test this algorithm, I (with some help) made a javascript simulation. You can see how the robot prefers turning over driving, and how it settles smoothly. . . Autonomous Code . Once I had the tracking and movement completed, it was time to make an API for me to use for writing autonomous programs. I wanted something flexible, abstract, and feature-packed. Here is what I ended up with: . . Settling . Every single autonomous motion has a settling period. However, I wanted the settling to be customizable for every single command. I wanted to be able to settle a few different ways: . All PID controllers come to a rest | All PID controllers get to some margin of error | The robot gets to a certain requirement, such as a certain distance from a point or a certain angle | . To do this, I created a parameter in each movement function that accepts a function pointer to handle the settling. Every loop, the movement function will ask the settling function “am I settled yet?” and then the function will return true when it’s conditions are met. . Then, I created a few default settling functions and added the functionality to generate new settling functions on the fly. For example, here is a command with a full settle that comes to a stop: chassis.driveToPoint({1_ft, 1_ft}, 1, driveSettle);. If I wanted to make the robot exit the movement when it was 4 inches away from the target, I could say chassis.driveToPoint({1_ft, 1_ft}, 1, makeSettle(4_in));. . Turning . All turning is essentially the same motion. The only difference with all possible turns is the goal calculation and movement method (point, pivot, or arc). To reduce redundancy, I wanted to write only one turning algorithm, and have all the implementations plug-in. Thus I used the same function pointer idea as the settling system and added parameters in the turning function to fulfill the angle calculation and movement method. Here are a few examples of a turn command: . chassis.turn(angleCalc({1_ft, 1_ft}), pointTurn, turnSettle); chassis.turn(angleCalc(90_deg), leftPivot, makeSettle(5_deg)); . For simplicity, I also made a few helper functions - turnToAngle(angle), turnAngle(angle), and turnToPoint(point), which all just call turn(angleCalc) in the backend. . AsyncAction . All the movement functions are blocking, but I still wanted to be able to trigger actions such as moving an arm in the middle of a movement. To do this I developed a system called AsyncAction, which requires a trigger (ex. min distance to point) and executes an action (ex. moves arm). In autonomous, used it to turn on the ball intake right when the robot reached the ball. . . Emergency Abort . There is nothing I dislike more than having the robot slightly off in autonomous, causing it to drive into a wall, and then being stuck there for the rest of the autonomous trying to push the wall over. Thus I made a system that detects when the robot is trying to move but is not moving. When it detects that the robot is stuck, it exits the current movement and goes on to the next one. With odometry, hopefully the robot will be able to continue the autonomous, because it still know its position even though it got stuck and had to abort a movement. . Result . All these abilities made programming autonomous much easier than before. I could use an image of the court to plan my autonomous and simply enter the coordinates of where I want the robot to be. Here are a few videos of our autonomous routines - I know they are not inherently impressive, but we did not have enough time to make many of them. . Notice how the base sometimes curves to get to the target point. . https://www.youtube.com/watch?v=_GutEusmo0g . https://www.youtube.com/watch?v=iPL_i5kivEM . . Vision Sensor . When the VEX Vision sensor came out at the beginning of last year, I was super interested in making an interface for it. I then noticed that the sensor was very unreliable, and the code for interfacing with the objects was quite limited. However, I wanted to use it for aligning with flags, so I set off to try and make the vision sensor better - using programming. . Filters and Sorting . First, I wanted to make filters. I wanted to filter tiny “noise” objects, abnormally sized objects, objects with abnormal proportions, etc. I also wanted to sort objects by arbitrary attributes and have an easy API to do so. This project has been at work all season, I have gone through many versions and it is not completed yet. Here is what my latest version can do: . reader.getAll(); // gets all objects from sensor // remove objects with area smaller than 200 and sort by size // commands can be chained reader.removeWith(objAttr::area, 0, 200).sortBy(objAttr::area); // only keep objects with signature 1 reader.removeWithout(objAttr::sig, 1); . The library can also display objects to the screen for debugging: . https://youtu.be/h7cOevYJF-U . It is likely I will release this library at some point this year when I am happy with it. . EMA Filtering . However, I noticed a problem with the vision sensor. The objects would often flicker and wobble, which I was worried would translate into oscillation and problems with filtering. So I decided that I needed to EMA filter the objects. This is a more difficult task than one would think, as I can’t simply filter by object index because the objects are ordered arbitrarily (or by size, not position). I won’t get into how I managed to do it in this post, but basically, I looked at the objects over time, kept track of where they were, ordered them, and then correlated the objects in a new snapshot with the previous snapshots. I could then EMA filter them. To develop this system, I used the LVGL simulator to test on my computer. If there is interest for me to make a guide on how to set up the simulator with C++, let me know. . I have had an interesting relationship with the vision sensor throughout the season. Despite all the work I did with it, I never got it to the point where I was comfortable using it in competition. It was just so frustrating to use and unreliable. Hopefully, VEX will fix the firmware for the vision sensor and it will become more practical for use. When I have the time I will keep working on my library so that it can be eventually released. . . 7842 Website . Earlier in the season, I designed a website for the online challenges. In hindsight I want to change a lot of things with it and improve the tutorials, but it still stands as a useful resource. I wrote a few tutorials about PROS and programming. Go check it out here! . Engineering Journals . Throughout the season Jacob did an amazing job of documenting our progress. He made two engineering journals, one for project management and ideas, and the other for linear build documentation. If you are interested in our design process, ideas, and more of our robot, check them out! They have earned us awards at every competition we have gone to, except for worlds, because unfortunately there our judging was rushed. However, later we were approached by the pair of judges that we were able to give our full presentation to and were complimented on our presentation. . I hope these journals are a great resource and that they provide a good learning opportunity! My favourite pages are the last 40 of the project journal. . . There are higher and lower-resolution versions, and the original images, available here. Enjoy! . Conclusion . This season has been really fun. Jacob and I have learned a lot and made it to Worlds together for the second time in a row. I have made huge advancements in my programming ability and have found a passion for it. . Unfortunately for me, Jacob has graduated this year and will be going to university. This leaves me as the team captain of a 1-person team with little building skills. Our club leadership has stepped down, leaving the club in a state of uncertainty. I have no idea what will happen in the following season, but I hope I can find a new robotics partner and continue the success of 7842F. . As for programming, I plan to create a library and implement some ideas I have been wanting to make for a while. Stay tuned! . Contact . If anyone has any questions or comments about this post, I am more than happy to answer them. If someone has suggestions to improve this post, let me know while I am still able to edit! . Also, feel free to contact me about programming questions in general on Discord at theol0403#6480. Just know that I will probably tell you to read learncpp.com. . For updates, follow us on our instagram account 7842F_vrc! . . I hope this has provided a valuable resource for future seasons and has taught someone something. Have a great season! .",
    "url": "https://theol0403.github.io/7842B-Journal/2019-08-19/robot-showcase/",
    "relUrl": "/2019-08-19/robot-showcase/"
  }
  
}