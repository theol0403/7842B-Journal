{
  
  "0": {
    "title": "",
    "content": "404 . Page not found :( . The requested page could not be found. .",
    "url": "http://localhost:4000/404.html",
    "relUrl": "/404.html"
  }
  ,"1": {
    "title": "GUI",
    "content": "Robot GUI . A large part of lib7842 is the GUI. It uses a third-party graphics library named LVGL for the elements. The GUI is fully tested and developed on my computer using a simulator, so that I donâ€™t need to have a V5 brain handy. . Here is a screenshot of the GUI: . . Tests . I use Microsoft Azure for tests and CI. Here are some screenshots of that: . .",
    "url": "http://localhost:4000/concepts/gui/",
    "relUrl": "/concepts/gui/"
  }
  ,"2": {
    "title": "Motion Algorithms",
    "content": "Motion Algorithms . A big focus for this year has been motion algorithms for autonomous. Motion algorithms allow for a faster, easier, and more competitive autonomous. This year, we have built an X-Drive robot, which opens up a wide range of possibilities. Having a holonomic chassis means that we can have heading-agnostic movement functions, meaning that we can drive anywhere while turning at a completely independent angle. . Odometry . To be able to have a consistent autonomous while not moving in linear or straight manners, we need robot localization. To do this, we used the odometry algorithm provided by team 5225A from Ontario. With the use of three freely-spinning tracking wheels, we are able to use trigonometry to calculate the absolute position of the robot in the field. . . To calculate absolute heading, we can use the following formula: . angleRadians = (leftInch - rightInch) / chassisWidthInch . Motion . Knowing where the robot is at all times allows us to do some pretty complex maneuvers. It allows us to do the following actions: . Turn to face Absolute Angle | Turn to face Point | Turn to face Relative Angle | Drive a Distance | Drive to a Point | . This means that we can program using coordinates from a map of the field: . . X-Drive . Having an X-Drive allows us to do some even more complex algorithms. To unlock this capability, I developed a function that allows me to tell the chassis to strafe at a certain angle and magnitude, using this math: . . With this math, I can say: . Drive to Point while facing Angle | Drive Distance while facing Angle | . Read our autonomous programs for a demonstration of this functionality. .",
    "url": "http://localhost:4000/concepts/motion/",
    "relUrl": "/concepts/motion/"
  }
  ,"3": {
    "title": "Odom Controller",
    "content": "Odom Controller . Here is the API (header file) for OdomController, which belongs to lib7842. . /** * Function that returns true to end chassis movement * Used to implement different settling methods */ using Settler = std::function&lt;bool(const OdomController&amp; odom)&gt;; /** * Function that accepts a turning velocity and controls excecution to the chassis * Used to implement a point or pivot turn */ using Turner = std::function&lt;void(ChassisModel&amp; model, double vel)&gt;; /** * Function that returns an angle for the chassis to seek * Examples can be an AngleCalculator that returns the angle to a point, or an angle to an absolute angle */ using AngleCalculator = std::function&lt;QAngle(const OdomController&amp; odom)&gt;; class OdomController { public: /** * OdomController. Implements chassis movement algorithms * * @param imodel The chassis model * @param iodometry The chassis odometry * @param idistanceController The distance pid controller * @param iturnController The turning pid controller * @param iangleController The angle pid controller, used to keep distance driving straight * @param isettleRadius The radius from the target point to give up angle correction */ OdomController( const std::shared_ptr&lt;ChassisModel&gt;&amp; imodel, const std::shared_ptr&lt;CustomOdometry&gt;&amp; iodometry, std::unique_ptr&lt;IterativePosPIDController&gt; idistanceController, std::unique_ptr&lt;IterativePosPIDController&gt; iturnController, std::unique_ptr&lt;IterativePosPIDController&gt; iangleController, const QLength&amp; isettleRadius); virtual ~OdomController() = default; /** * Turn the chassis using the given AngleCalculator * * @param angleCalculator The angle calculator * @param turner The turner * @param settler The settler */ virtual void turn( const AngleCalculator&amp; angleCalculator, const Turner&amp; turner = pointTurn, const Settler&amp; settler = defaultTurnSettler); /** * Turn the chassis to face an absolue angle * * @param angle The angle * @param turner The turner * @param settler The settler */ virtual void turnToAngle( const QAngle&amp; angle, const Turner&amp; turner = pointTurn, const Settler&amp; settler = defaultTurnSettler); /** * Turn the chassis to face a relative angle * * @param angle The angle * @param turner The turner * @param settler The settler */ virtual void turnAngle( const QAngle&amp; angle, const Turner&amp; turner = pointTurn, const Settler&amp; settler = defaultTurnSettler); /** * Turn the chassis to face a point * * @param point The point * @param turner The turner * @param settler The settler */ virtual void turnToPoint( const Vector&amp; point, const Turner&amp; turner = pointTurn, const Settler&amp; settler = defaultTurnSettler); /** * Drive a distance while correcting angle using an AngleCalculator * * @param distance The distance * @param angleCalculator The angle calculator * @param turnScale The turn scale * @param settler The settler */ virtual void moveDistanceAtAngle( const QLength&amp; distance, const AngleCalculator&amp; angleCalculator, double turnScale, const Settler&amp; settler = defaultDriveSettler); /** * Drive a distance while maintaining starting angle * * @param distance The distance * @param settler The settler */ virtual void moveDistance(const QLength&amp; distance, const Settler&amp; settler = defaultDriveSettler); /** * Drive to a point using custom point seeking * * @param targetPoint The target point * @param turnScale The turn scale used to control the priority of turning over driving. A higher value will make * the robot turn to face the point sooner * @param settler The settler */ virtual void driveToPoint( const Vector&amp; targetPoint, double turnScale = 1, const Settler&amp; settler = defaultDriveSettler); /** * Drive to a point using simple point seeking * * @param targetPoint The target point * @param turnScale The turn scale used to control the priority of turning over driving. A higher value will make * the robot turn to face the point sooner * @param settler The settler */ virtual void driveToPoint2( const Vector&amp; targetPoint, double turnScale = 1, const Settler&amp; settler = defaultDriveSettler); /** * A Settler that is used for turning which uses the turning pid&#39;s isSettled() method */ static bool defaultTurnSettler(const OdomController&amp; odom); /** * A Settler that is used for driving which uses the distance pid&#39;s isSettled() method */ static bool defaultDriveSettler(const OdomController&amp; odom); /** * A Settler that is used for driving which uses the distance and angle pid&#39;s isSettled() method */ static bool defaultDriveAngleSettler(const OdomController&amp; odom); /** * A Turner that excecutes a point turn which turns in place. Used as default for turn functions */ static void pointTurn(ChassisModel&amp; model, double vel); /** * A Turner that excecutes a left pivot, meaning it only moves the left motors. */ static void leftPivot(ChassisModel&amp; model, double vel); /** * A Turner that excecutes a right pivot, meaning it only moves the right motors. */ static void rightPivot(ChassisModel&amp; model, double vel); /** * Make a Settler that exits when angle error is within given range * @param angle The angle error theshold */ static Settler makeSettler(const QAngle&amp; angle); /** * Make a Settler that exits when distance error is within given range * @param distance The distance error theshold */ static Settler makeSettler(const QLength&amp; distance); /** * Make a Settler that exits when both angle and distance error is within given range. * @param angle The angle error theshold * @param distance The distance error theshold */ static Settler makeSettler(const QLength&amp; distance, const QAngle&amp; angle); /** * Generates an AngleCalculator that seeks a given absolute angle * * @param angle The angle */ static AngleCalculator makeAngleCalculator(const QAngle&amp; angle); /** * Generates an AngleCaclulator that seeks a given point. * * @param point The point */ static AngleCalculator makeAngleCalculator(const Vector&amp; point); /** * Generates an AngleCaclulator that returns a constant error. * * @param error The error */ static AngleCalculator makeAngleCalculator(double error); /** * Generates an AngleCalculator that does nothing */ static AngleCalculator makeAngleCalculator(); /** * Calculates angle from the chassis to the point */ QAngle angleToPoint(const Vector&amp; point) const; /** * Calculates distance from the chassis to the point */ QLength distanceToPoint(const Vector&amp; point) const; protected: /** * Resets the pid controllers, used before every motion */ virtual void resetPid(); /** * Controls the chassis movement * Applies magnitude control to prioritize turning * * @param forwardSpeed Forward speed * @param yaw The yaw */ void driveVector(double forwardSpeed, double yaw); std::shared_ptr&lt;ChassisModel&gt; model {nullptr}; std::shared_ptr&lt;CustomOdometry&gt; odometry {nullptr}; std::unique_ptr&lt;IterativePosPIDController&gt; distanceController {nullptr}; std::unique_ptr&lt;IterativePosPIDController&gt; angleController {nullptr}; std::unique_ptr&lt;IterativePosPIDController&gt; turnController {nullptr}; const QLength settleRadius; QAngle angleErr = 0_deg; QLength distanceErr = 0_in; }; . Odom X Controller . Here is the API for OdomXController, which implements strafing algorithms: . class OdomXController : public OdomController { public: /** * OdomXController. Implements chassis movement algorithms for the X drive. * * @param imodel The chassis model * @param iodometry The chassis odometry * @param idistanceController The distance pid controller * @param iturnController The turning pid controller * @param iangleController The angle pid controller, used to keep distance driving straight * @param istrafeController The strafe pid controller * @param isettleRadius The radius from the target point to give up angle correction */ OdomXController( const std::shared_ptr&lt;XDriveModel&gt;&amp; imodel, const std::shared_ptr&lt;CustomOdometry&gt;&amp; iodometry, std::unique_ptr&lt;IterativePosPIDController&gt; idistanceController, std::unique_ptr&lt;IterativePosPIDController&gt; iturnController, std::unique_ptr&lt;IterativePosPIDController&gt; iangleController, std::unique_ptr&lt;IterativePosPIDController&gt; istrafeController, const QLength&amp; isettleRadius); virtual ~OdomXController() = default; /** * Strafe a distance in a relative direction while correcting angle using an AngleCalculator * * @param distance The distance * @param direction The relative direction of the strafing * @param angleCalculator The angle calculator * @param turnScale The turn scale * @param settler The settler */ virtual void strafeDistance( const QLength&amp; distance, const QAngle&amp; direction, const AngleCalculator&amp; angleCalculator = makeAngleCalculator(), double turnScale = 1, const Settler&amp; settler = defaultDriveSettler); /** * Strafe a distance in an absolute direction while correcting angle using an AngleCalculator * * @param distance The distance * @param direction The absolute direction of the strafing * @param angleCalculator The angle calculator * @param turnScale The turn scale * @param settler The settler */ virtual void strafeDistanceAtDirection( const QLength&amp; distance, const QAngle&amp; direction, const AngleCalculator&amp; angleCalculator = makeAngleCalculator(), double turnScale = 1, const Settler&amp; settler = defaultDriveSettler); /** * Drive to a point using custom point seeking for strafing and an AngleCalculator * * @param targetPoint The target point * @param angleCalculator The angle calculator * @param turnScale The turn scale used to control the priority of turning over driving. A higher value will * make the robot turn to face the point sooner * @param settler The settler */ virtual void driveToPoint( const Vector&amp; targetPoint, const AngleCalculator&amp; angleCalculator = makeAngleCalculator(), double turnScale = 1, const Settler&amp; settler = defaultStrafeSettler); /** * Drive to a point using custom point seeking * * @param targetPoint The target point * @param turnScale The turn scale used to control the priority of turning over driving. A higher value will make * the robot turn to face the point sooner * @param settler The settler */ void driveToPoint( const Vector&amp; targetPoint, double turnScale = 1, const Settler&amp; settler = defaultStrafeSettler) override; /** * Drive to a point using custom point seeking for strafing and an AngleCalculator * * @param targetPoint The target point * @param angleCalculator The angle calculator * @param settler The settler */ virtual void strafeToPoint( const Vector&amp; targetPoint, const AngleCalculator&amp; angleCalculator = makeAngleCalculator(), double turnScale = 1, const Settler&amp; settler = defaultDriveSettler); /** * A Settler that is used for driving/strafing which uses the distance and strafe pid&#39;s isSettled() method */ static bool defaultStrafeSettler(const OdomController&amp; odom); protected: /** * Resets the pid controllers, used before every motion */ void resetPid() override; /** * Controls the chassis movement. Applies magnitude control to prioritize turning. * * @param forwardSpeed The forward speed * @param yaw The yaw speed * @param strafe The strafe speed */ void driveXVector(double forwardSpeed, double yaw, double strafe); /** * Controls the chassis movement. Strafes at the given speed at the given direction. * * @param speed The speed * @param direction The direction * @param yaw The yaw */ void strafeXVector(double speed, const QAngle&amp; direction, double yaw); std::shared_ptr&lt;XDriveModel&gt; model {nullptr}; std::unique_ptr&lt;IterativePosPIDController&gt; strafeController {nullptr}; }; .",
    "url": "http://localhost:4000/concepts/odom/",
    "relUrl": "/concepts/odom/"
  }
  ,"4": {
    "title": "State Machine",
    "content": "Statemachine Wrapper . A statemachine is an elegant way of programming a subsystem, and makes it easy to control both in driver control and autonomous. A statemachine is usually implemented using an enum containing a list of states, and then a switch statement in a separate thread that implements each state. . However, implementing a statemachine requires a substantial amount of boilerplate, both to set up the task but also to set up the setter and getter functions. This is why I wrote an abstract StateMachine wrapper that reduces said boilerplate. StateMachine inherits task functionality from Task Wrapper. . Here is the class, which accepts the enum type as a template parameter: . /** * State machine helper class. * * @tparam States An enum class representing the states of a subsystem. Required to have an * off state. * @tparam assumedState Optional - The assumed last state when using setNewState. Initially calling * setNewState with this state will not trigger a state transition. */ template &lt;typename States, States assumedState = States::off&gt; class StateMachine : public TaskWrapper { public: StateMachine() = default; virtual ~StateMachine() = default; /** * Sets the state. * * @param istate The state */ virtual void setState(const States&amp; istate) { state = istate; } /** * Sets the state only if the state is different from the last time this function was called. * * @param istate The state */ virtual void setNewState(const States&amp; istate) { if (istate != lastState) { state = istate; lastState = istate; } } /** * Gets the state. * * @return The state. */ virtual const States&amp; getState() const { return state; } protected: /** * Override this method to implement setup procedures. */ virtual void calibrate() = 0; /** * Override this method to implement the statemachine task */ void loop() override = 0; States state {States::off}; States lastState {assumedState}; }; .",
    "url": "http://localhost:4000/concepts/statemachine/",
    "relUrl": "/concepts/statemachine/"
  }
  ,"5": {
    "title": "Task Wrapper",
    "content": "Task Wrapper . If a class requires a task as a member, it causes some problems. A pros::Task requires a callback function to run, but due to some limitations in c++, the address of that function needs to be known in compile-time. This means that the task callback needs to be static , which means that it does not belong to the class instance and it canâ€™t access class members. To fix this, a pattern named trampoline is used. Trampoline is the act of passing a opaque pointer to the class object through the task to be received by the static function, having the static function cast the pointer to the correct class type, and calling a member function to execute the task. . Since implementing a trampoline requires a solid amount of boilerplate, I have written an abstract task wrapper that does this for me. To be able to run using unit tests and CI, I am using OkapiLibâ€™s CrossPlatformTask as the task object. . Note how the this pointer is passed when task is constructed: . task = std::make_unique&lt;CrossplatformThread&gt;(trampoline, this, iname.c_str()); . Then, the pointer is cast by the trampoline and a virtual member loop() is called, which is then resolved by dynamic binding: . void TaskWrapper::trampoline(void* iparam) { pros::delay(20); static_cast&lt;TaskWrapper*&gt;(iparam)-&gt;loop(); } . Here is the full TaskWrapper implementation: . /** * A utility class that wraps a task trampoline. To use, simply inherit your class from TaskWrapper * and override the `loop` method. To start the task, the `startTask` method must be called, either * from the constructor or from outside the class. */ class TaskWrapper { protected: explicit TaskWrapper(const std::shared_ptr&lt;Logger&gt;&amp; ilogger = Logger::getDefaultLogger()); TaskWrapper(const TaskWrapper&amp; itask) = delete; TaskWrapper(TaskWrapper&amp;&amp; itask) = default; virtual ~TaskWrapper() = default; /** * Override this function to implement a custom task loop. * Will throw if not overridden. */ virtual void loop(); public: /** * Start the task. * * @param iname The task name, optional. */ virtual void startTask(const std::string&amp; iname = &quot;TaskWrapper&quot;); /** * Kill the task. */ virtual void killTask(); /** * Get the task name. * * @return The name. */ virtual std::string getName(); protected: std::shared_ptr&lt;Logger&gt; logger {nullptr}; private: static void trampoline(void* iparam); std::unique_ptr&lt;CrossplatformThread&gt; task {nullptr}; }; . Source file: . TaskWrapper::TaskWrapper(const std::shared_ptr&lt;Logger&gt;&amp; ilogger) : logger(ilogger) {} void TaskWrapper::loop() { std::string msg(&quot;TaskWrapper::loop: loop is not overridden&quot;); LOG_ERROR(msg); throw std::runtime_error(msg); } void TaskWrapper::startTask(const std::string&amp; iname) { if (task) LOG_INFO(&quot;TaskWrapper::startTask: restarting task: &quot; + iname); task = std::make_unique&lt;CrossplatformThread&gt;(trampoline, this, iname.c_str()); } void TaskWrapper::killTask() { task = nullptr; } std::string TaskWrapper::getName() { return task-&gt;getName(); }; void TaskWrapper::trampoline(void* iparam) { pros::delay(20); static_cast&lt;TaskWrapper*&gt;(iparam)-&gt;loop(); } .",
    "url": "http://localhost:4000/concepts/task/",
    "relUrl": "/concepts/task/"
  }
  ,"6": {
    "title": "",
    "content": "7842F Programming Journal . Hello, Iâ€™m Theo, the programmer for team 7842F. This is my journal where I will keep programming logs of my progress and ideas. . . Journal Layout: . Daily logs will be kept in Logs/. Concepts and ideas will be kept in Concepts/. lib7842 development logs will be kept in lib7842/. Code dumps will be kept in Code/. .",
    "url": "http://localhost:4000/",
    "relUrl": "/"
  }
  ,"7": {
    "title": "lib7842",
    "content": "lib7842 . lib7842 is a library I am developing for the VEX community. I will be developing it through the season and hopefully have it released by the end of the year. . It will consist of: . Customizable path generation | Pure Pursuit | Custom odometry motion controller | GUI API | Vision sensor filtering | Other utilities Iâ€™ve made | . Best Practices: . Git . Make a commit for every change made | Use gitmoji to indicate commit intent | Use imperative tense for commit messages | Use git flow and make feature branches for large improvements | . | Code Style Use const references when passing values | cppcheck runs static analysis | . | Formatting Formatting is handled by clang-format-9 | Install a clang-format package into your editor so you can format as you type | . | CI and Tests This project uses Google Test and OkapiLib mocks | Tests need to be made for each public API | Each commit is compiled and tested by Azure Pipelines | Results from CI include: V5 build logs and template | Test build logs and results | Valgrind memory leak detector results | Callgrind profiler results | CppCheck static analysis | Codacity static analysis | Codefactor static analysis | . | . | . Commit Messages . Here is an example of lib7842 commit messages: . . Tests . lib7842 uses GoogleTest, a unit testing framework. Here is an example of a test: . TEST_F(SimplePathTest, ExtractCopy) { SimplePath path({point1, point1}); SimplePath ipath = path.copy(); ASSERT_EQ(ipath().size(), 2); for (size_t i = 0; i &lt; path().size(); i++) { // pointers should not be equal ASSERT_NE(path()[i], ipath()[i]); // values should be equal ASSERT_EQ(*path()[i], point1); } } .",
    "url": "http://localhost:4000/lib7842",
    "relUrl": "/lib7842"
  }
  
}